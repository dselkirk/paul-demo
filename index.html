<!DOCTYPE html>
<html lang="en" class="no-js">
<head>
    <meta charset="UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Практические задания</title>
    <link rel="shortcut icon" href="../favicon.ico">
    <link rel="stylesheet" type="text/css" href="css/normalize.css"/>
    <link rel="stylesheet" type="text/css" href="fonts/font-awesome-4.3.0/css/font-awesome.min.css"/>
    <link rel="stylesheet" type="text/css" href="css/style1.css"/>
    <script src="js/modernizr.custom.js"></script>
</head>
<body>
<div class="container">
    <button id="menu-toggle" class="menu-toggle"><span>Menu</span></button>
    <div id="theSidebar" class="sidebar">
        <button class="close-button fa fa-fw fa-close"></button>
        <h1>Практические работы</h1>

        <div class="related">
            <h3>Павел Самарцев</h3>
        </div>
    </div>
    <div id="theGrid" class="main">
        <section class="grid">
            <a class="grid__item" href="#">
                <h2 class="title title--preview">Формы представления алгоритмов</h2>

                <div class="loader"></div>
                <div class="meta meta--preview">
                    <span class="meta__date"><i class="fa fa-calendar-o"></i> 2015</span>
                    <span class="meta__reading-time"><i class="fa fa-clock-o"></i> 2 часа</span>
                </div>
            </a>
            <a class="grid__item" href="#">
                <h2 class="title title--preview">Машина Поста</h2>

                <div class="loader"></div>
                <div class="meta meta--preview">
                    <span class="meta__date"><i class="fa fa-calendar-o"></i> 2015</span>
                    <span class="meta__reading-time"><i class="fa fa-clock-o"></i> 2 часа</span>
                </div>
            </a>
            <a class="grid__item" href="#">
                <h2 class="title title--preview">Сортировка и поиск</h2>

                <div class="loader"></div>
                <div class="meta meta--preview">
                    <span class="meta__date"><i class="fa fa-calendar-o"></i> 2015</span>
                    <span class="meta__reading-time"><i class="fa fa-clock-o"></i> 4 часа</span>
                </div>
            </a>
            <a class="grid__item" href="#">
                <h2 class="title title--preview">Задача коммивояжера. Алгоритм ближайшего соседа</h2>

                <div class="loader"></div>
                <div class="meta meta--preview">
                    <span class="meta__date"><i class="fa fa-calendar-o"></i> 2015</span>
                    <span class="meta__reading-time"><i class="fa fa-clock-o"></i> 2 часа</span>
                </div>
            </a>
            <a class="grid__item" href="#">
                <h2 class="title title--preview">Алгоритм поиска минимального остовного дерева</h2>

                <div class="loader"></div>
                <div class="meta meta--preview">
                    <span class="meta__date"><i class="fa fa-calendar-o"></i> 2015</span>
                    <span class="meta__reading-time"><i class="fa fa-clock-o"></i> 2 часа</span>
                </div>
            </a>
            <a class="grid__item" href="#">
                <h2 class="title title--preview">Алгоритм топологической сортировки</h2>

                <div class="loader"></div>
                <div class="meta meta--preview">
                    <span class="meta__date"><i class="fa fa-calendar-o"></i> 2015</span>
                    <span class="meta__reading-time"><i class="fa fa-clock-o"></i> 2 часа</span>
                </div>
            </a>
            <a class="grid__item" href="#">
                <h2 class="title title--preview">Алгоритм Прима</h2>

                <div class="loader"></div>
                <div class="meta meta--preview">
                    <span class="meta__date"><i class="fa fa-calendar-o"></i> 2015</span>
                    <span class="meta__reading-time"><i class="fa fa-clock-o"></i> 2 часа</span>
                </div>
            </a>
            <a class="grid__item" href="#">
                <h2 class="title title--preview">Алгоритм Дейкстры</h2>

                <div class="loader"></div>
                <div class="meta meta--preview">
                    <span class="meta__date"><i class="fa fa-calendar-o"></i> 2015</span>
                    <span class="meta__reading-time"><i class="fa fa-clock-o"></i> 2 часа</span>
                </div>
            </a>
            <a class="grid__item" href="#">
                <h2 class="title title--preview">Эффективность алгоритмов</h2>

                <div class="loader"></div>
                <div class="meta meta--preview">
                    <span class="meta__date"><i class="fa fa-calendar-o"></i> 2015</span>
                    <span class="meta__reading-time"><i class="fa fa-clock-o"></i> 2 часа</span>
                </div>
            </a>
        </section>
        <section class="content">
            <div class="scroll-wrap">
                <article class="content__item">
                    <span class="category category--full">Практическое занятие №1</span>

                    <h2 class="title title--full">Формы представления алгоритмов</h2>

                    <div class="practice-title">
                        <p class="proved right">УТВЕРЖДЕНО</p>

                        <p class="date right">«&nbsp;&nbsp;» ________ 2015 г.</p>

                        <p class="date-sub right">Дата</p>

                        <p class="discipline center">Дисциплина: Теория алгоритмов </p>

                        <h2 class="center">Практическое занятие № 1</h2>

                        <p class="center">Наименование: Формы представления алгоритмов</p>

                        <p class="spec indent">по специальности:</p>

                        <p class="spec indent">09.02.03 – Программирование в компьютерных системах</p>

                        <p class="spec indent">Количество часов <u>2</u></p>

                        <p class="new-part indent">РАССМОТРЕНО</p>

                        <p class="indent">на заседании цикловой комиссии <u>Информационные системы и технологии</u></p>

                        <p class="comission indent">наименование П(Ц)К</p>

                        <p class="indent">Председатель ____________<u>/ Шомас Е.А. /</u></p>

                        <p class="sign indent">подпись <span>расшифровка подписи</span></p>

                        <p class="indent">Протокол __________ от «&nbsp;&nbsp;» <u>04</u> 2015 г.</p>

                        <p class="protocol indent">номер <span>дата</span></p>

                        <p class="right">Составил преподаватель</p>

                        <p class="right">Пронина Т.С.</p>

                        <p class="center">Самара, КС ПГУТИ, 2015</p>
                    </div>
                    <div class="practice-info">
                        <p class="center bold">Практическое занятие №1</p>
                        <ol>
                            <li><span class="bold">Наименование</span>: Формы представления алгоритмов</li>
                            <li><span class="bold">Цель занятия</span>: Изучить формы представления алгоритмов</li>
                            <li><span class="bold">Подготовка к занятию</span>:
                                <ol>
                                    <li>Изучить формы представления алгоритмов</li>
                                    <li>Ответить на вопросы для допуска к занятию
                                        <ol>
                                            <li>Что такое алгоритм, исполнитель алгоритма, среда алгоритма?</li>
                                            <li>В какой форме может быть представлен алгоритм?</li>
                                            <li>Приведите примеры задач, решаемых с помощью алгоритмов.</li>
                                        </ol>
                                    </li>
                                </ol>
                            </li>
                            <li><span class="bold">Литература</span>:
                                <ol>
                                    <li>Конспект лекций по учебной дисциплине «Теория алгоритмов»</li>
                                    <li>Приложение к практическому занятию №1</li>
                                </ol>
                            </li>
                            <li><span class="bold">Перечень используемых материалов</span>:
                                <ol>
                                    <li>Канцелярские принадлежности</li>
                                    <li>Описание практического занятия</li>
                                </ol>
                            </li>
                            <li><span class="bold">Задание на занятие</span>:
                                <div class="italic">Основная часть</div>
                                <p>
                                    <span class="bold">Задача 1</span> Имеется исполнитель Кузнечик, который живет на
                                    числовой
                                    оси. Система команд Кузнечика: «Вперед N» (Кузнечик прыгает вперед на N
                                    единиц); «Назад М» (Кузнечик прыгает назад на М единиц). Переменные N
                                    и М могут принимать любые целые положительные значения. Известно, что
                                    Кузнечик выполнил программу из 50 команд, в которой команд «Назад 2» на
                                    12 больше, чем команд «Вперед 3». Других команд в программе не было. На
                                    какую одну команду можно заменить эту программу, чтобы Кузнечик
                                    оказался в той же точке, что и после выполнения программы?</p>

                                <p><span class="bold">Задача 2</span> Исполнитель Черепашка перемещается на экране
                                    компьютера, оставляя след в виде линии. В каждый конкретный момент
                                    известно положение исполнителя и направление его движения. У
                                    исполнителя существует две команды:

                                <div>«Вперёд n», где n целое число, вызывающая передвижение Черепашки
                                    на n шагов в направлении движения.
                                </div>
                                <div>«Направо m», где т целое число, вызывающая изменение направления
                                    движения на m градусов по часовой стрелке.
                                </div>
                                <div>Запись Повтори 5 [Команда 1, Команда 2] означает, что
                                    последовательность команд в скобках повторится 5 раз.
                                </div>
                                <div>Черепашке был дан для исполнения следующий алгоритм:</div>
                                <div>Повтори 5 [Вперед 10 Направо 72]</div>
                                Какая фигура появится на экране?


                                <p><span class="bold">Задача 3</span> Исполнитель Робот действует на клетчатой доске,
                                    между
                                    соседними клетками которой могут стоять стены. Робот передвигается по
                                    клеткам доски и может выполнять команды 1 (вверх), 2 (вниз), 3 (вправо) и 4
                                    (влево), переходя на соседнюю клетку в направлении, указанном в скобках.
                                    Если в этом направлении между клетками стоит стена, то Робот разрушается.
                                    Робот успешно выполнил программу 1132432.</p>

                                <div>Какую последовательность из четырех команд должен выполнить
                                    Робот, чтобы вернуться в ту клетку, где он был перед началом выполнения
                                    программы, и не разрушиться вне зависимости от того, какие стены стоят на
                                    поле?
                                </div>

                                <div><span class="bold">Задача 4</span> Определите значение целочисленных переменных a и
                                    b
                                    после
                                    выполнения фрагмента программы на алгоритмическом языке:
                                </div>

                                <div>a:= 2468</div>
                                <div>b:= mod(a, 1000) • 10</div>
                                <div>a:=div(a,1000)+b</div>
                                <div>|div и mod – функции, вычисляющие результат деления нацело первого
                                    аргумента на второй и остаток от деления соответственно |
                                </div>
                                <p><span class="bold">Задача 5</span> Определите значение переменной a после выполнения фрагмента алгоритма:</p>

                                <div><img src="img/practices/1/1.png" alt=""/></div>

                                <div class="italic">Вариативная часть</div>
                                <p><span class="bold">Задача 1</span> Определите значение целочисленных переменных a и b
                                    после
                                    выполнения фрагмента программы на алгоритмическом языке:</p>

                                <div>a:=42</div>
                                <div>b:=14</div>
                                <div>a:=div(a, b)</div>
                                <div>b:=a • b</div>
                                <div>a:=div(b,a) | div - стандартная функция, вычисляющая результат
                                    деления нацело первого аргумента на второй |
                                </div>

                                <p><span class="bold">Задача 2</span> В понедельник в одном из классов должно быть
                                    проведено 4
                                    урока – по математике, физике, информатике и биологии. Учителя высказали свои
                                    пожелания для
                                    составления расписания. Учитель математики хочет иметь первый или второй урок,
                                    учитель
                                    физики - второй или третий урок, учитель информатики – первый или четвертый, учитель
                                    биологии – третий или четвертый. Какой вариант расписания устроит всех учителей
                                    школы?</p>

                                <div>(Обозначения: М – математика, Ф – физика, И – информатика, Б – биология)</div>

                                <p><span class="bold">Задача 3</span> Определите значение переменной А после выполнения
                                    следующего алгоритма: </p>

                                <div><img src="img/practices/1/2.png" alt=""/></div>
                            </li>
                            <li><span class="bold">Порядок выполнения работы</span>:
                                <ol>
                                    <li>Получите допуск к занятию</li>
                                    <li>Решите задачи 1-5</li>
                                    <li>Сдайте зачет</li>
                                    <li>В случае успешной сдачи зачета приступите к решению вариативной части</li>
                                </ol>
                            </li>
                            <li><span class="bold">Содержание отчета</span>:
                                <div class="italic">Основная часть</div>
                                <div class="italic">Вариативная часть</div>
                            </li>
                            <li><span class="bold">Контрольные вопросы</span>:
                                <ol>
                                    <li>Перечислите свойства алгоритма и дайте пояснение по каждому пункту.</li>
                                    <li>Укажите все условные обозначения для блок – схем алгоритмов.</li>
                                </ol>
                            </li>
                        </ol>
                        <div class="work-done-by">
                            <span>Работу составил преподаватель</span>
                            <span class="right-float">Пронина Т.С.</span>
                        </div>


                        <div class="additional">
                            <p class="center bold">Приложение А к практическому занятию №1</p>
                            <ul>
                                <li>1 Имеется исполнитель Кузнечик, который живет на числовой оси. Система команд
                                    Кузнечика: «Вперед N» (Кузнечик прыгает вперед на N единиц); «Назад М» (Кузнечик
                                    прыгает назад на М единиц). Переменные N и М могут принимать любые целые
                                    положительные значения. Известно, что Кузнечик выполнил команду из 40 команд, в
                                    которой команд «Назад 2» на 10 больше, чем команд «Вперед 3». Других команд в
                                    программе не было. На какую одну команду можно заменить эту программу, чтобы
                                    Кузнечик оказался в той же точке, что и после выполнения программы?
                                    <div class="bold">Решение:</div>
                                    <div>Если всего команд 40, то команд «Назад 2» было 25, а «Вперед 3» всего 15.
                                        Кузнечик прыгнул вперед на 15•3= 45 шагов, а назад на 25•2= 50 шагов. Тем самым,
                                        он оказался на 5 шагов от первоначальной точки. Последовательность команд в
                                        алгоритме в данном случае не имеет значения.
                                    </div>
                                    <div><span class="bold">Ответ:</span> Назад 5</div>
                                </li>
                                <li>
                                    <p>2 Исполнитель Черепашка перемещается на экране
                                        компьютера, оставляя след в виде линии. В каждый конкретный момент
                                        известно положение исполнителя и направление его движения. У
                                        исполнителя существует две команды:</p>

                                    <div>«Вперёд n», где n целое число, вызывающая передвижение Черепашки
                                        на n шагов в направлении движения.
                                    </div>
                                    <div>«Направо m», где т целое число, вызывающая изменение направления
                                        движения на m градусов по часовой стрелке.
                                    </div>
                                    <div>Запись Повтори 5 [Команда 1, Команда 2] означает, что
                                        последовательность команд в скобках повторится 5 раз.
                                    </div>
                                    <div>Черепашке был дан для исполнения следующий алгоритм:</div>
                                    <div>Повтори 5 [Вперед 10 Направо 72]</div>
                                    Какая фигура появится на экране?
                                    <div class="bold">Решение:</div>
                                    <div>Черепашка прочертит на экране 4 линии, но последний отрезок полностью совпадет
                                        с первым, так как после третьего выполнения цикла черепашка полностью обернется
                                        вокруг своей оси и окажется в той же точке, что и изначально. Так что на экране
                                        появится правильный треугольник.
                                    </div>
                                </li>
                                <li>
                                    <div>3 Исполнитель Робот действует на клетчатой доске, между соседними клетками
                                        которой могут стоять стены. Робот передвигается по клеткам доски и может
                                        выполнять команды 1 (вверх), 2 (вниз), 3 (вправо) и 4 (влево), переходя на
                                        соседнюю клетку в направлении, указанном в скобках. Если в этом направлении
                                        между клетками стоит стена, то Робот разрушается. Робот успешно выполнил
                                        программу 3233241
                                    </div>
                                    <div>Какую последовательность из четырех команд должен выполнить Робот, чтобы
                                        вернуться в ту клетку, где он был перед началом выполнения программы, и не
                                        разрушиться вне зависимости от того, какие стены стоят на поле?
                                    </div>
                                    <div class="bold">Решение:</div>
                                    <div>Начертим траекторию, по которой двигался Робот. Обозначим буквой А - начальную
                                        точку его движения, В – конечную. Из рисунка видно, что возвращение из точки В в
                                        точку А можно осуществить по программе из трех команд: влево – вверх – влево,
                                        т.е. 414.
                                    </div>
                                    <div><img src="img/practices/1/3.png" alt=""/></div>
                                    <div><span class="bold">Ответ:</span> 414</div>
                                </li>
                                <li>
                                    <div>4 Определите значение целочисленных переменных х, у, и t после выполнения
                                        фрагмента программы на алгоритмическом языке:
                                    </div>
                                    <div>x:= 5;</div>
                                    <div>y:=7;</div>
                                    <div>t:=x;</div>
                                    <div>x:=mod(y,x);</div>
                                    <div>| mod – стандартная функция, вычисляющая остаток от деления нацело первого
                                        аргумента на второй | y:=t;
                                    </div>
                                    <div class="bold">Решение:</div>
                                    <table class="practice-table" style="width: 100%;">
                                        <tbody>
                                        <tr>
                                            <th>Шаг</th>
                                            <th>Значение x после шага</th>
                                            <th>Значение у после шага</th>
                                            <th>Значение t после шага</th>
                                        </tr>
                                        <tr>
                                            <td>x= 5</td>
                                            <td>5</td>
                                            <td>не определено</td>
                                            <td>не определено</td>
                                        </tr>
                                        <tr>
                                            <td>y=7</td>
                                            <td>5</td>
                                            <td>7</td>
                                            <td>не определено</td>
                                        </tr>
                                        <tr>
                                            <td>t=x</td>
                                            <td>5</td>
                                            <td>7</td>
                                            <td>5</td>
                                        </tr>
                                        <tr>
                                            <td>x=y MOD x</td>
                                            <td>2</td>
                                            <td>7</td>
                                            <td>5</td>
                                        </tr>
                                        <tr>
                                            <td>y=t</td>
                                            <td>2</td>
                                            <td>5</td>
                                            <td>5</td>
                                        </tr>
                                        </tbody>
                                    </table>
                                    <div><span class="bold">Ответ:</span> x=2, y=5, t=5</div>
                                </li>
                                <li>
                                    <div>5 <div>Определите значение целочисленной переменной x после выполнения следующего фрагмента программы:</div>
                                        <div><img src="img/practices/1/4.png" alt=""/></div>
                                    </div>
                                    <div class="bold">Решение:</div>
                                    <div>В блок-схеме присутствует цикл, т.е. одни и те же команды многократно повторяются. Для того, чтобы не ошибиться при выполнении блок схемы, удобно составить табличку, в которую заносятся значения переменных и результаты проверки условия на каждом шаге.</div>
                                    <span class="bold">Примечание:</span> . Знак <> означает «не равно», знак := - присваивание значения.
                                    <table class="practice-table" style="width: 100%;">
                                        <tbody>
                                        <tr>
                                            <th>N итерации цикла</th>
                                            <th>Значение x</th>
                                            <th>Значение y</th>
                                            <th>x<>y</th>
                                            <th>x>y</th>
                                        </tr>
                                        <tr>
                                            <td>0</td>
                                            <td>55</td>
                                            <td>75</td>
                                            <td>55<>75 – да (выполняем тело цикла)</td>
                                            <td>0</td>
                                        </tr>
                                        <tr>
                                            <td>1</td>
                                            <td>55</td>
                                            <td>75</td>
                                            <td></td>
                                            <td>55>75 – нет (вычитаем x из y)</td>
                                        </tr>
                                        <tr>
                                            <td>1</td>
                                            <td>55</td>
                                            <td>20</td>
                                            <td></td>
                                            <td></td>
                                        </tr>
                                        <tr>
                                            <td></td>
                                            <td>55</td>
                                            <td>20</td>
                                            <td>55<>20 – да (выполняем тело цикла )</td>
                                            <td></td>
                                        </tr>
                                        <tr>
                                            <td>2</td>
                                            <td>35</td>
                                            <td>20</td>
                                            <td></td>
                                            <td></td>
                                        </tr>
                                        <tr>
                                            <td></td>
                                            <td>35</td>
                                            <td>20</td>
                                            <td>35<>20 – да (выполняем тело цикла)</td>
                                            <td></td>
                                        </tr>
                                        <tr>
                                            <td>3</td>
                                            <td>35</td>
                                            <td>20</td>
                                            <td></td>
                                            <td>35>20 – да (вычитаем y из x )</td>
                                        </tr>
                                        <tr>
                                            <td>3</td>
                                            <td>15</td>
                                            <td>20</td>
                                            <td></td>
                                            <td></td>
                                        </tr>
                                        <tr>
                                            <td></td>
                                            <td>15</td>
                                            <td>20</td>
                                            <td>15<>20 – да (выполняем тело цикла)</td>
                                            <td></td>
                                        </tr>
                                        <tr>
                                            <td>4</td>
                                            <td>15</td>
                                            <td>20</td>
                                            <td></td>
                                            <td>15>20 – да (вычитаем y из x )</td>
                                        </tr>
                                        <tr>
                                            <td>4</td>
                                            <td>15</td>
                                            <td>5</td>
                                            <td></td>
                                            <td></td>
                                        </tr>
                                        <tr>
                                            <td>4</td>
                                            <td>15</td>
                                            <td>5</td>
                                            <td>15<>5 – да (выполняем тело цикла)</td>
                                            <td></td>
                                        </tr>
                                        <tr>
                                            <td>5</td>
                                            <td>15</td>
                                            <td>5</td>
                                            <td></td>
                                            <td>15>5 – да (вычитаем y из x )</td>
                                        </tr>
                                        <tr>
                                            <td>5</td>
                                            <td>15</td>
                                            <td>5</td>
                                            <td></td>
                                            <td></td>
                                        </tr>
                                        <tr>
                                            <td>5</td>
                                            <td>10</td>
                                            <td>5</td>
                                            <td></td>
                                            <td></td>
                                        </tr>
                                        <tr>
                                            <td></td>
                                            <td>10</td>
                                            <td>5</td>
                                            <td>10<>5 – да (выполняем тело цикла)</td>
                                            <td></td>
                                        </tr>
                                        <tr>
                                            <td>6</td>
                                            <td>10</td>
                                            <td>5</td>
                                            <td></td>
                                            <td>10>5 – да (вычитаем y из x )</td>
                                        </tr>
                                        <tr>
                                            <td>6</td>
                                            <td>5</td>
                                            <td>5</td>
                                            <td></td>
                                            <td></td>
                                        </tr>
                                        <tr>
                                            <td></td>
                                            <td>5</td>
                                            <td>5</td>
                                            <td>5<>5 – да (алгоритм завершен)</td>
                                            <td></td>
                                        </tr>
                                        </tbody>
                                    </table>
                                    <div>Итак, переменная x после выполнения данного фрагмента программы приняла значение 5, что соответствует ответу под номером 2 в таблице ответов.</div>

                                    <div><span class="bold">Ответ:</span> 2</div>
                                </li>
                            </ul>
                            <p class="center bold">Приложение Б к практическому занятию №1</p>
                            <ul>
                                <li>
                                    <div class="bold">Вариант 1</div>
                                    Определите значение переменной с после выполнения фрагмента алгоритма:
                                    <div><img src="img/practices/1/var1.png" alt=""/></div>
                                    <div class="italic">Примечание: знаком * обозначено умножение, знаком := обозначена операция присваивания.</div>
                                </li>
                                <li>
                                    <div class="bold">Вариант3</div>
                                    Определите значение переменной b после выполнения фрагмента алгоритма:
                                    <div><img src="img/practices/1/var2.png" alt=""/></div>
                                    <div class="italic">Примечание: знаком * обозначено умножение, знаком := обозначена операция присваивания.</div>
                                </li>
                                <li>
                                    <div class="bold">Вариант 3</div>
                                    Определите значение переменной A после выполнения следующего  алгоритма:
                                    <div><img src="img/practices/1/var3.png" alt=""/></div>
                                    <div class="italic">Примечание: знаком * обозначено умножение, знаком := обозначена операция присваивания.</div>
                                </li>
                                <li>
                                    <div class="bold">Вариант 4</div>
                                    Определите значение переменной s после выполнения следующего  алгоритма:
                                    <div><img src="img/practices/1/var4.png" alt=""/></div>
                                    <div class="italic">Примечание: знаком * обозначено умножение, знаком := обозначена операция присваивания.</div>
                                </li>
                                <li>
                                    <div class="bold">Вариант 5</div>
                                    Определите значение целочисленной переменной x после выполнения следующего фрагмента программы:
                                    <div><img src="img/practices/1/var5.png" alt=""/></div>
                                    <div class="italic">Примечание: знаком * обозначено умножение, знаком := обозначена операция присваивания.</div>
                                </li>
                                <li>
                                    <div class="bold">Вариант 6</div>
                                    Определите значение переменной B после выполнения следующего  алгоритма:
                                    <div><img src="img/practices/1/var6.png" alt=""/></div>
                                    <div class="italic">Примечание: знаком * обозначено умножение, знаком := обозначена операция присваивания.</div>
                                </li>
                                <li>
                                    <div class="bold">Вариант 7</div>
                                    Определите значение переменной с после выполнения фрагмента алгоритма:
                                    <div><img src="img/practices/1/var7.png" alt=""/></div>
                                    <div class="italic">Примечание: знаком * обозначено умножение, знаком := обозначена операция присваивания.</div>
                                </li>
                                <li>
                                    <div class="bold">Вариант 8</div>
                                    Определите значение переменной a после выполнения фрагмента алгоритма:
                                    <div><img src="img/practices/1/var8.png" alt=""/></div>
                                    <div class="italic">Примечание: знаком * обозначено умножение, знаком := обозначена операция присваивания.</div>
                                </li>
                                <li>
                                    <div class="bold">Вариант 9</div>
                                    Определите значение переменной m после выполнения фрагмента алгоритма:
                                    <div><img src="img/practices/1/var9.png" alt=""/></div>
                                    <div class="italic">Примечание: знаком * обозначено умножение, знаком := обозначена операция присваивания.</div>
                                </li>
                                <li>
                                    <div class="bold">Вариант 10</div>
                                    Определите значение переменной с после выполнения фрагмента алгоритма:
                                    <div><img src="img/practices/1/var10.png" alt=""/></div>
                                    <div class="italic">Примечание: знаком * обозначено умножение, знаком := обозначена операция присваивания.</div>
                                </li>
                                <li>
                                    <div class="bold">Вариант 11</div>
                                    Определите значение переменной a после выполнения фрагмента алгоритма:
                                    <div><img src="img/practices/1/var11.png" alt=""/></div>
                                    <div class="italic">Примечание: знаком * обозначено умножение, знаком := обозначена операция присваивания.</div>
                                </li>
                                <li>
                                    <div class="bold">Вариант 12</div>
                                    Определите значение переменной c после выполнения фрагмента алгоритма:
                                    <div><img src="img/practices/1/var12.png" alt=""/></div>
                                    <div class="italic">Примечание: знаком * обозначено умножение, знаком := обозначена операция присваивания.</div>
                                </li>
                                <li>
                                    <div class="bold">Вариант 13</div>
                                    Определите корни квадратного уравнения:
                                    <div><img src="img/practices/1/var13.png" alt=""/></div>
                                    <div class="italic">Примечание: знаком * обозначено умножение, знаком := обозначена операция присваивания.</div>
                                </li>
                                <li>
                                    <div class="bold">Вариант 14</div>
                                    Определите НОД для чисел M=54, N=81:
                                    <div><img src="img/practices/1/var14.png" alt=""/></div>
                                    <div class="italic">Примечание: знаком * обозначено умножение, знаком := обозначена операция присваивания.</div>
                                </li>
                                <li>
                                    <div class="bold">Вариант 15</div>
                                    Определите значение факториала n=4:
                                    <div><img src="img/practices/1/var15.png" alt=""/></div>
                                    <div class="italic">Примечание: знаком * обозначено умножение, знаком := обозначена операция присваивания.</div>
                                </li>
                                <li>
                                    <div class="bold">Вариант 16</div>
                                    Определите значение переменной m после выполнения фрагмента алгоритма:
                                    <div><img src="img/practices/1/var16.png" alt=""/></div>
                                    <div class="italic">Примечание: знаком * обозначено умножение, знаком := обозначена операция присваивания.</div>
                                </li>
                                <li>
                                    <div class="bold">Вариант 17</div>
                                    Определите корни квадратного уравнения:
                                    <div><img src="img/practices/1/var17.png" alt=""/></div>
                                    <div class="italic">Примечание: знаком * обозначено умножение, знаком := обозначена операция присваивания.</div>
                                </li>
                                <li>
                                    <div class="bold">Вариант 18</div>
                                    Определите значение целочисленной переменной x после выполнения следующего фрагмента программы:
                                    <div><img src="img/practices/1/var18.png" alt=""/></div>
                                    <div class="italic">Примечание: знаком * обозначено умножение, знаком := обозначена операция присваивания.</div>
                                </li>
                                <li>
                                    <div class="bold">Вариант 19</div>
                                    Определите значение переменной B после выполнения следующего  алгоритма:
                                    <div><img src="img/practices/1/var19.png" alt=""/></div>
                                    <div class="italic">Примечание: знаком * обозначено умножение, знаком := обозначена операция присваивания.</div>
                                </li>
                                <li>
                                    <div class="bold">Вариант 20</div>
                                    Определите значение переменной с после выполнения фрагмента алгоритма:
                                    <div><img src="img/practices/1/var20.png" alt=""/></div>
                                    <div class="italic">Примечание: знаком * обозначено умножение, знаком := обозначена операция присваивания.</div>
                                </li>
                                <li>
                                    <div class="bold">Вариант 21</div>
                                    Определите значение переменной a после выполнения фрагмента алгоритма:
                                    <div><img src="img/practices/1/var21.png" alt=""/></div>
                                    <div class="italic">Примечание: знаком * обозначено умножение, знаком := обозначена операция присваивания.</div>
                                </li>
                                <li>
                                    <div class="bold">Вариант 22</div>
                                    Определите значение переменной m после выполнения фрагмента алгоритма:
                                    <div><img src="img/practices/1/var22.png" alt=""/></div>
                                    <div class="italic">Примечание: знаком * обозначено умножение, знаком := обозначена операция присваивания.</div>
                                </li>
                                <li>
                                    <div class="bold">Вариант 23</div>
                                    Определите значение переменной с после выполнения фрагмента алгоритма:
                                    <div><img src="img/practices/1/var23.png" alt=""/></div>
                                    <div class="italic">Примечание: знаком * обозначено умножение, знаком := обозначена операция присваивания.</div>
                                </li>
                                <li>
                                    <div class="bold">Вариант 24</div>
                                    Определите значение переменной a после выполнения фрагмента алгоритма:
                                    <div><img src="img/practices/1/var24.png" alt=""/></div>
                                    <div class="italic">Примечание: знаком * обозначено умножение, знаком := обозначена операция присваивания.</div>
                                </li>
                                <li>
                                    <div class="bold">Вариант 25</div>
                                    Определите значение переменной c после выполнения фрагмента алгоритма:
                                    <div><img src="img/practices/1/var25.png" alt=""/></div>
                                    <div class="italic">Примечание: знаком * обозначено умножение, знаком := обозначена операция присваивания.</div>
                                </li>
                                <li>
                                    <div class="bold">Вариант 26</div>
                                    Определите корни квадратного уравнения:
                                    <div><img src="img/practices/1/var26.png" alt=""/></div>
                                    <div class="italic">Примечание: знаком * обозначено умножение, знаком := обозначена операция присваивания.</div>
                                </li>
                                <li>
                                    <div class="bold">Вариант 27</div>
                                    Определите НОД для чисел M=62, N=97:
                                    <div><img src="img/practices/1/var27.png" alt=""/></div>
                                    <div class="italic">Примечание: знаком * обозначено умножение, знаком := обозначена операция присваивания.</div>
                                </li>
                                <li>
                                    <div class="bold">Вариант 28</div>
                                    Определите значение факториала n=7:
                                    <div><img src="img/practices/1/var28.png" alt=""/></div>
                                    <div class="italic">Примечание: знаком * обозначено умножение, знаком := обозначена операция присваивания.</div>
                                </li>
                                <li>
                                    <div class="bold">Вариант 29</div>
                                    Определите значение переменной m после выполнения фрагмента алгоритма:
                                    <div><img src="img/practices/1/var29.png" alt=""/></div>
                                    <div class="italic">Примечание: знаком * обозначено умножение, знаком := обозначена операция присваивания.</div>
                                </li>
                                <li>
                                    <div class="bold">Вариант 30</div>
                                    Определите корни квадратного уравнения:
                                    <div><img src="img/practices/1/var30.png" alt=""/></div>
                                    <div class="italic">Примечание: знаком * обозначено умножение, знаком := обозначена операция присваивания.</div>
                                </li>

                            </ul>
                            <p class="center bold">Приложение В к практическому занятию №1</p>
                            <ul>
                                <li>
                                    <div class="bold">Вариант 1</div>
                                    Определите значение целочисленных переменных x, y, и t после выполнения фрагмента программы  (ниже представлена одна и та же программа, записанная на разных языках программирования):
                                    <table class="practice-table" style="width: 100%;">
                                        <tbody>
                                        <tr>
                                            <th>Бейсик</th>
                                            <th>Паскаль</th>
                                            <th>Алгоритмический</th>
                                        </tr>
                                        <tr>
                                            <td>
                                                <pre>
x =10
y =14
t = x
` MOD – стандартная операция, вычисляющая остаток от  деления нацело первого аргумента на второй
x=y MOD x
y=t
                                                </pre>
                                            </td>
                                            <td>
                                                <pre>
x:=10;
y:=14;
t:=x;
x:=y mod x;
{mod - стандартная операция, вычисляющая остаток от  деления нацело первого аргумента на второй}
y:=t;
                                                </pre>
                                            </td>
                                            <td>
<pre>
x:=10;
y:=14;
t:=x;
x:=mod (y,x); | mod -стандартная функция, вычисляющая остаток от  деления нацело первого аргумента на второй|
y:=t;
</pre>
                                            </td>
                                        </tr>
                                        </tbody>
                                    </table>
                                </li>
                                <li>
                                    <div class="bold">Вариант 2</div>
                                    Определите значение целочисленных переменных a, и b после выполнения фрагмента программы (ниже представлена одна и та же программа, записанная на разных языках программирования):
                                    <table class="practice-table" style="width: 100%;">
                                        <tbody>
                                        <tr>
                                            <th>Бейсик</th>
                                            <th>Паскаль</th>
                                            <th>Алгоритмический</th>
                                        </tr>
                                        <tr>
                                            <td>
                                                <pre>
a =42
b =14
a = a\b
b = a*b
a = b\a
\ - стандартная операция, вычисляющая результат деления нацело первого аргумента на второй

                                                </pre>
                                            </td>
                                            <td>
                                                <pre>
a:=42;
b:=14;
a:=a div b;
b:=a*b;
a:=b div a;
{div - стандартная операция, вычисляющая результат деления нацело первого аргумента на второй }

                                                </pre>
                                            </td>
                                            <td>
<pre>
a:=42
b:=14
a:=div(a, b)
b:=a*b
a:=div(b, a)
| div - стандартная функция, вычисляющая результат деления нацело первого аргумента на второй |
</pre>
                                            </td>
                                        </tr>
                                        </tbody>
                                    </table>
                                </li>
                                <li>
                                    <div class="bold">Вариант 3</div>
                                    Определите значение целочисленных переменных a, и b после выполнения фрагмента программы (ниже представлена одна и та же программа, записанная на разных языках программирования):
                                    <table class="practice-table" style="width: 100%;">
                                        <tbody>
                                        <tr>
                                            <th>Бейсик</th>
                                            <th>Паскаль</th>
                                            <th>Алгоритмический</th>
                                        </tr>
                                        <tr>
                                            <td>
                                                <pre>
a =2468
b =(a MOD 1000)*10
a = a\1000+b
`\ и MOD - операции, вычисляющие результат деления нацело первого аргумента на второй и остаток от деления соответственно

                                                </pre>
                                            </td>
                                            <td>
                                                <pre>
a:= 2468;
b:= (a mod 1000)*10;
a:=a div 1000+b;
{div и mod - операции, вычисляющие результат деления нацело первого аргумента на второй и остаток от деления соответственно }

                                                </pre>
                                            </td>
                                            <td>
<pre>
a:=2468
b:= mod (a,1000)*10;
a:=div(a,1000)+b
| div и mod - функции, вычисляющие результат деления нацело первого аргумента на второй и остаток от деления соответственно |
</pre>
                                            </td>
                                        </tr>
                                        </tbody>
                                    </table>
                                </li>
                                <li>
                                    <div class="bold">Вариант 4</div>
                                    Определите значение целочисленных переменных x, y, и t после выполнения фрагмента программы (ниже представлена одна и та же программа, записанная на разных языках программирования):
                                    <table class="practice-table" style="width: 100%;">
                                        <tbody>
                                        <tr>
                                            <th>Бейсик</th>
                                            <th>Паскаль</th>
                                            <th>Алгоритмический</th>
                                        </tr>
                                        <tr>
                                            <td>
                                                <pre>
x =4
y =16
t = x
` MOD – стандартная операция, вычисляющая остаток от  деления нацело первого аргумента на второй
x=y MOD x
y=t +1
                                                </pre>
                                            </td>
                                            <td>
                                                <pre>
x:=4;
y:=16;
t:=x;
x:=y mod x;
{mod - стандартная операция, вычисляющая остаток от  деления нацело первого аргумента на второй}
y:=t+1;
                                                </pre>
                                            </td>
                                            <td>
<pre>
x:=4;
y:=16;
t:=x;
x:=mod (y,x); | mod -стандартная функция, вычисляющая остаток от  деления нацело первого аргумента на второй|
y:=t+1;
</pre>
                                            </td>
                                        </tr>
                                        </tbody>
                                    </table>
                                </li>
                                <li>
                                    <div class="bold">Вариант 5</div>
                                    Определите значение целочисленных переменных b и c после выполнения фрагмента программы (ниже представлена одна и та же программа, записанная на разных языках программирования):
                                    <table class="practice-table" style="width: 100%;">
                                        <tbody>
                                        <tr>
                                            <th>Бейсик</th>
                                            <th>Паскаль</th>
                                            <th>Алгоритмический</th>
                                        </tr>
                                        <tr>
                                            <td>
                                                <pre>
a =37
b =a MOD 10
c= a\10
\ - стандартная операция, вычисляющая результат деления нацело первого аргумента на второй
                                                </pre>
                                            </td>
                                            <td>
                                                <pre>
a:= 37;
b:= a MOD 10;
c:=a div 10;
{div - стандартная операция, вычисляющая результат деления нацело первого аргумента на второй }
                                                </pre>
                                            </td>
                                            <td>
<pre>
a:=37
b:= mod (a,10);
c:=div(a,10);
|div - стандартная функция, вычисляющая результат деления нацело первого аргумента на второй |

</pre>
                                            </td>
                                        </tr>
                                        </tbody>
                                    </table>
                                </li>
                                <li>
                                    <div class="bold">Вариант 6</div>
                                    Определите значение целочисленных переменных a, и b после выполнения фрагмента программы (ниже представлена одна и та же программа, записанная на разных языках программирования):
                                    <table class="practice-table" style="width: 100%;">
                                        <tbody>
                                        <tr>
                                            <th>Бейсик</th>
                                            <th>Паскаль</th>
                                            <th>Алгоритмический</th>
                                        </tr>
                                        <tr>
                                            <td>
                                                <pre>
a =20
b =7
a = a\b
b = a*b
a = b\a
\ - стандартная операция, вычисляющая результат деления нацело первого аргумента на второй

                                                </pre>
                                            </td>
                                            <td>
                                                <pre>
a:=20;
b:=7;
a:=a div b;
b:=a*b;
a:=b div a;
{div - стандартная операция, вычисляющая результат деления нацело первого аргумента на второй }
                                                </pre>
                                            </td>
                                            <td>
<pre>
a:=20
b:=7
a:=div(a, b)
b:=a*b
a:=div(b, a)
| div - стандартная функция, вычисляющая результат деления нацело первого аргумента на второй |
</pre>
                                            </td>
                                        </tr>
                                        </tbody>
                                    </table>
                                </li>
                                <li>
                                    <div class="bold">Вариант 7</div>
                                    Определите значение переменной c после выполнения следующего фрагмента программы (ниже представлена одна и та же программа, записанная на разных языках программирования):
                                    <table class="practice-table" style="width: 100%;">
                                        <tbody>
                                        <tr>
                                            <th>Бейсик</th>
                                            <th>Паскаль</th>
                                            <th>Алгоритмический</th>
                                        </tr>
                                        <tr>
                                            <td>
                                                <pre>
a =5
a = a+6
b = -a
c = a – 2 * b

                                                </pre>
                                            </td>
                                            <td>
                                                <pre>
a:=5;
a:=a+6;
b:= -a;
c:=a – 2 * b;

                                                </pre>
                                            </td>
                                            <td>
<pre>
a:=5
a:=a+6
b:= -a
c:=a – 2 * b
</pre>
                                            </td>
                                        </tr>
                                        </tbody>
                                    </table>
                                </li>
                                <li>
                                    <div class="bold">Вариант 8</div>
                                    Определите значение целочисленных переменных a и b после выполнения фрагмента программы (ниже представлена одна и та же программа, записанная на разных языках программирования):
                                    <table class="practice-table" style="width: 100%;">
                                        <tbody>
                                        <tr>
                                            <th>Бейсик</th>
                                            <th>Паскаль</th>
                                            <th>Алгоритмический</th>
                                        </tr>
                                        <tr>
                                            <td>
                                                <pre>
a = 1819
b = (a \100)*10+9
a = (10*b – a) MOD 100
`\ и MOD - операции, вычисляющие результат деления нацело первого аргумента на второй и остаток от деления соответственно

                                                </pre>
                                            </td>
                                            <td>
                                                <pre>
a:= 1819;
b:= (a div 100)*10+9;
a:= (10*b – a) mod 100;
{div и mod - операции, вычисляющие результат деления нацело первого аргумента на второй и остаток от деления соответственно }

                                                </pre>
                                            </td>
                                            <td>
<pre>
a:= 1819
b:= div (a,100)*10+9;
a:= mod (10*b – a ,100)
| div и mod - функции, вычисляющие результат деления нацело первого аргумента на второй и остаток от деления соответственно |
</pre>
                                            </td>
                                        </tr>
                                        </tbody>
                                    </table>
                                </li>
                                <li>
                                    <div class="bold">Вариант 9</div>
                                    Определите значение целочисленных переменных a и b после выполнения фрагмента программы (ниже представлена одна и та же программа, записанная на разных языках программирования):
                                    <table class="practice-table" style="width: 100%;">
                                        <tbody>
                                        <tr>
                                            <th>Бейсик</th>
                                            <th>Паскаль</th>
                                            <th>Алгоритмический</th>
                                        </tr>
                                        <tr>
                                            <td>
                                                <pre>
a = 3 + 8 * 4
b = (a \10) + 14
a = (b MOD 10) + 2
\ и MOD - операции, вычисляющие результат деления нацело первого аргумента на второй и остаток от деления соответственно

                                                </pre>
                                            </td>
                                            <td>
                                                <pre>
a:= 3 + 8 * 4;
b:= (a div 10) + 14;
a:= (b mod 10) + 2;
{div и mod - операции, вычисляющие результат деления нацело первого аргумента на второй и остаток от деления соответственно }

                                                </pre>
                                            </td>
                                            <td>
<pre>
a:= 3 + 8 * 4
b:= div (a,10) + 14;
a:= mod (b,10) + 2
| div и mod - функции, вычисляющие результат деления нацело первого аргумента на второй и остаток от деления соответственно |
</pre>
                                            </td>
                                        </tr>
                                        </tbody>
                                    </table>
                                </li>
                                <li>
                                    <div class="bold">Вариант 10</div>
                                    Определите значение целочисленных переменных a и b после выполнения фрагмента программы (ниже представлена одна и та же программа, записанная на разных языках программирования):
                                    <table class="practice-table" style="width: 100%;">
                                        <tbody>
                                        <tr>
                                            <th>Бейсик</th>
                                            <th>Паскаль</th>
                                            <th>Алгоритмический</th>
                                        </tr>
                                        <tr>
                                            <td>
                                                <pre>
a =4321
b =(a MOD 100) + 22
a= (a*10)\100 – b * 10
                                                </pre>
                                            </td>
                                            <td>
                                                <pre>
a:= 4321;
b:= (a mod 100) + 22;
a:=(a*10) div 100 – b*10;

                                                </pre>
                                            </td>
                                            <td>
<pre>
a:=4321
b:= mod (a,100) + 22
a:=div((a*10),100) – b*10

</pre>
                                            </td>
                                        </tr>
                                        </tbody>
                                    </table>
                                </li>
                                <li>
                                    <div class="bold">Вариант 11</div>
                                    Определите значение целочисленных переменных a и b после выполнения фрагмента программы (ниже представлена одна и та же программа, записанная на разных языках программирования):
                                    <table class="practice-table" style="width: 100%;">
                                        <tbody>
                                        <tr>
                                            <th>Бейсик</th>
                                            <th>Паскаль</th>
                                            <th>Алгоритмический</th>
                                        </tr>
                                        <tr>
                                            <td>
                                                <pre>
a=2025
b=(a MOD 1000) – (a\100)
a=(b+a) MOD 1000

                                                </pre>
                                            </td>
                                            <td>
                                                <pre>
a:= 2025;
b:= (a mod 1000) – (a div 100);
a:= (b+a) mod 1000;

                                                </pre>
                                            </td>
                                            <td>
<pre>
a:=2025
b:= mod (a,1000) – div (a, 100);
a:= mod (b+a,1000)

</pre>
                                            </td>
                                        </tr>
                                        </tbody>
                                    </table>
                                </li>
                                <li>
                                    <div class="bold">Вариант 12</div>
                                    Определите значение целочисленных переменных a и b после выполнения фрагмента программы (ниже представлена одна и та же программа, записанная на разных языках программирования):
                                    <table class="practice-table" style="width: 100%;">
                                        <tbody>
                                        <tr>
                                            <th>Бейсик</th>
                                            <th>Паскаль</th>
                                            <th>Алгоритмический</th>
                                        </tr>
                                        <tr>
                                            <td>
                                                <pre>
a =1234
b =(a \ 1000) * 101
a= (b MOD 10) + a

                                                </pre>
                                            </td>
                                            <td>
                                                <pre>
a:= 1234;
b:= (a div 1000) *101;
a:= (b mod 10) + a;

                                                </pre>
                                            </td>
                                            <td>
<pre>
a:=1234
b:=div (a,1000) * 101
a:= mod (b,10) + a

</pre>
                                            </td>
                                        </tr>
                                        </tbody>
                                    </table>
                                </li>
                                <li>
                                    <div class="bold">Вариант 13</div>
                                    Определите значение целочисленных переменных x, y, и t после выполнения фрагмента программы  (ниже представлена одна и та же программа, записанная на разных языках программирования):
                                    <table class="practice-table" style="width: 100%;">
                                        <tbody>
                                        <tr>
                                            <th>Бейсик</th>
                                            <th>Паскаль</th>
                                            <th>Алгоритмический</th>
                                        </tr>
                                        <tr>
                                            <td>
                                                <pre>
x =23
y =31
t = x
` MOD – стандартная операция, вычисляющая остаток от  деления нацело первого аргумента на второй
x=y MOD x
y=t

                                                </pre>
                                            </td>
                                            <td>
                                                <pre>
x:=23;
y:=31;
t:=x;
x:=y mod x;
{mod - стандартная операция, вычисляющая остаток от  деления нацело первого аргумента на второй}
y:=t;
                                                </pre>
                                            </td>
                                            <td>
<pre>
x:=23;
y:=31;
t:=x;
x:=mod (y,x); | mod -стандартная функция, вычисляющая остаток от  деления нацело первого аргумента на второй|
y:=t;
</pre>
                                            </td>
                                        </tr>
                                        </tbody>
                                    </table>
                                </li>
                                <li>
                                    <div class="bold">Вариант 14</div>
                                    Определите значение целочисленных переменных a, и b после выполнения фрагмента программы (ниже представлена одна и та же программа, записанная на разных языках программирования):
                                    <table class="practice-table" style="width: 100%;">
                                        <tbody>
                                        <tr>
                                            <th>Бейсик</th>
                                            <th>Паскаль</th>
                                            <th>Алгоритмический</th>
                                        </tr>
                                        <tr>
                                            <td>
                                                <pre>
a =72
b =9
a = a\b
b = a*b
a = b\a
\ - стандартная операция, вычисляющая результат деления нацело первого аргумента на второй

                                                </pre>
                                            </td>
                                            <td>
                                                <pre>
a:=72;
b:=9;
a:=a div b;
b:=a*b;
a:=b div a;
{div - стандартная операция, вычисляющая результат деления нацело первого аргумента на второй }

                                                </pre>
                                            </td>
                                            <td>
<pre>
a:=72
b:=9
a:=div(a, b)
b:=a*b
a:=div(b, a)
| div - стандартная функция, вычисляющая результат деления нацело первого аргумента на второй |

</pre>
                                            </td>
                                        </tr>
                                        </tbody>
                                    </table>
                                </li>
                                <li>
                                    <div class="bold">Вариант 15</div>
                                    Определите значение целочисленных переменных a, и b после выполнения фрагмента программы (ниже представлена одна и та же программа, записанная на разных языках программирования):
                                    <table class="practice-table" style="width: 100%;">
                                        <tbody>
                                        <tr>
                                            <th>Бейсик</th>
                                            <th>Паскаль</th>
                                            <th>Алгоритмический</th>
                                        </tr>
                                        <tr>
                                            <td>
                                                <pre>
a =4356
b =(a MOD 1000)*10
a = a\1000+b
`\ и MOD - операции, вычисляющие результат деления нацело первого аргумента на второй и остаток от деления соответственно

                                                </pre>
                                            </td>
                                            <td>
                                                <pre>
a:= 4356;
b:= (a mod 1000)*10;
a:=a div 1000+b;
{div и mod - операции, вычисляющие результат деления нацело первого аргумента на второй и остаток от деления соответственно }

                                                </pre>
                                            </td>
                                            <td>
<pre>
a:=4356
b:= mod (a,1000)*10;
a:=div(a,1000)+b
| div и mod - функции, вычисляющие результат деления нацело первого аргумента на второй и остаток от деления соответственно |

</pre>
                                            </td>
                                        </tr>
                                        </tbody>
                                    </table>
                                </li>
                                <li>
                                    <div class="bold">Вариант 16</div>
                                    Определите значение целочисленных переменных x, y, и t после выполнения фрагмента программы (ниже представлена одна и та же программа, записанная на разных языках программирования):
                                    <table class="practice-table" style="width: 100%;">
                                        <tbody>
                                        <tr>
                                            <th>Бейсик</th>
                                            <th>Паскаль</th>
                                            <th>Алгоритмический</th>
                                        </tr>
                                        <tr>
                                            <td>
                                                <pre>
x =9
y =33
t = x
` MOD – стандартная операция, вычисляющая остаток от  деления нацело первого аргумента на второй
x=y MOD x
y=t +1

                                                </pre>
                                            </td>
                                            <td>
                                                <pre>
x:=9;
y:=33;
t:=x;
x:=y mod x;
{mod - стандартная операция, вычисляющая остаток от  деления нацело первого аргумента на второй}
y:=t+1;

                                                </pre>
                                            </td>
                                            <td>
<pre>
x:=9;
y:=33;
t:=x;
x:=mod (y,x); | mod -стандартная функция, вычисляющая остаток от  деления нацело первого аргумента на второй|
y:=t+1;

</pre>
                                            </td>
                                        </tr>
                                        </tbody>
                                    </table>
                                </li>
                                <li>
                                    <div class="bold">Вариант 17</div>
                                    Определите значение целочисленных переменных b и c после выполнения фрагмента программы (ниже представлена одна и та же программа, записанная на разных языках программирования):
                                    <table class="practice-table" style="width: 100%;">
                                        <tbody>
                                        <tr>
                                            <th>Бейсик</th>
                                            <th>Паскаль</th>
                                            <th>Алгоритмический</th>
                                        </tr>
                                        <tr>
                                            <td>
                                                <pre>
a =25
b =a MOD 10
c= a\10
\ - стандартная операция, вычисляющая результат деления нацело первого аргумента на второй

                                                </pre>
                                            </td>
                                            <td>
                                                <pre>
a:= 25;
b:= a MOD 10;
c:=a div 10;
{div - стандартная операция, вычисляющая результат деления нацело первого аргумента на второй }

                                                </pre>
                                            </td>
                                            <td>
<pre>
a:=25
b:= mod (a,10);
c:=div(a,10);
|div - стандартная функция, вычисляющая результат деления нацело первого аргумента на второй |

</pre>
                                            </td>
                                        </tr>
                                        </tbody>
                                    </table>
                                </li>
                                <li>
                                    <div class="bold">Вариант 18</div>
                                    Определите значение целочисленных переменных a, и b после выполнения фрагмента программы (ниже представлена одна и та же программа, записанная на разных языках программирования):
                                    <table class="practice-table" style="width: 100%;">
                                        <tbody>
                                        <tr>
                                            <th>Бейсик</th>
                                            <th>Паскаль</th>
                                            <th>Алгоритмический</th>
                                        </tr>
                                        <tr>
                                            <td>
                                                <pre>
a =60
b =21
a = a\b
b = a*b
a = b\a
\ - стандартная операция, вычисляющая результат деления нацело первого аргумента на второй

                                                </pre>
                                            </td>
                                            <td>
                                                <pre>
a:=60;
b:=21;
a:=a div b;
b:=a*b;
a:=b div a;
{div - стандартная операция, вычисляющая результат деления нацело первого аргумента на второй }

                                                </pre>
                                            </td>
                                            <td>
<pre>
a:=60
b:=21
a:=div(a, b)
b:=a*b
a:=div(b, a)
| div - стандартная функция, вычисляющая результат деления нацело первого аргумента на второй |

</pre>
                                            </td>
                                        </tr>
                                        </tbody>
                                    </table>
                                </li>
                                <li>
                                    <div class="bold">Вариант 19</div>
                                    Определите значение переменной c после выполнения следующего фрагмента программы (ниже представлена одна и та же программа, записанная на разных языках программирования):
                                    <table class="practice-table" style="width: 100%;">
                                        <tbody>
                                        <tr>
                                            <th>Бейсик</th>
                                            <th>Паскаль</th>
                                            <th>Алгоритмический</th>
                                        </tr>
                                        <tr>
                                            <td>
                                                <pre>
a =8
a = a+17
b = -a
c = a – 5* b

                                                </pre>
                                            </td>
                                            <td>
                                                <pre>
a:=8;
a:=a+17;
b:= -a;
c:=a – 5 * b;

                                                </pre>
                                            </td>
                                            <td>
<pre>
a:=8
a:=a+17
b:= -a
c:=a – 5 * b

</pre>
                                            </td>
                                        </tr>
                                        </tbody>
                                    </table>
                                </li>
                                <li>
                                    <div class="bold">Вариант 20</div>
                                    Определите значение целочисленных переменных a и b после выполнения фрагмента программы (ниже представлена одна и та же программа, записанная на разных языках программирования):
                                    <table class="practice-table" style="width: 100%;">
                                        <tbody>
                                        <tr>
                                            <th>Бейсик</th>
                                            <th>Паскаль</th>
                                            <th>Алгоритмический</th>
                                        </tr>
                                        <tr>
                                            <td>
                                                <pre>
a = 2365
b = (a \100)*10+14
a = (10*b – a) MOD 100
`\ и MOD - операции, вычисляющие результат деления нацело первого аргумента на второй и остаток от деления соответственно

                                                </pre>
                                            </td>
                                            <td>
                                                <pre>
a:= 2365;
b:= (a div 100)*10+14;
a:= (10*b – a) mod 100;
{div и mod - операции, вычисляющие результат деления нацело первого аргумента на второй и остаток от деления соответственно }

                                                </pre>
                                            </td>
                                            <td>
<pre>
a:= 2365
b:= div (a,100)*10+14;
a:= mod (10*b – a ,100)
| div и mod - функции, вычисляющие результат деления нацело первого аргумента на второй и остаток от деления соответственно |

</pre>
                                            </td>
                                        </tr>
                                        </tbody>
                                    </table>
                                </li>
                                <li>
                                    <div class="bold">Вариант 21</div>
                                    Определите значение целочисленных переменных a и b после выполнения фрагмента программы (ниже представлена одна и та же программа, записанная на разных языках программирования):
                                    <table class="practice-table" style="width: 100%;">
                                        <tbody>
                                        <tr>
                                            <th>Бейсик</th>
                                            <th>Паскаль</th>
                                            <th>Алгоритмический</th>
                                        </tr>
                                        <tr>
                                            <td>
                                                <pre>
a = 8 + 12 * 7
b = (a \10) + 23
a = (b MOD 10) + 7
\ и MOD - операции, вычисляющие результат деления нацело первого аргумента на второй и остаток от деления соответственно

                                                </pre>
                                            </td>
                                            <td>
                                                <pre>
a:= 8 + 12 * 7;
b:= (a div 10) + 23;
a:= (b mod 10) + 7;
{div и mod - операции, вычисляющие результат деления нацело первого аргумента на второй и остаток от деления соответственно }

                                                </pre>
                                            </td>
                                            <td>
<pre>
a:= 8 + 12 * 7
b:= div (a,10) + 23;
a:= mod (b,10) + 7
| div и mod - функции, вычисляющие результат деления нацело первого аргумента на второй и остаток от деления соответственно |

</pre>
                                            </td>
                                        </tr>
                                        </tbody>
                                    </table>
                                </li>
                                <li>
                                    <div class="bold">Вариант 22</div>
                                    Определите значение целочисленных переменных a и b после выполнения фрагмента программы (ниже представлена одна и та же программа, записанная на разных языках программирования):
                                    <table class="practice-table" style="width: 100%;">
                                        <tbody>
                                        <tr>
                                            <th>Бейсик</th>
                                            <th>Паскаль</th>
                                            <th>Алгоритмический</th>
                                        </tr>
                                        <tr>
                                            <td>
                                                <pre>
a =6589
b =(a MOD 100) + 45
a= (a*10)\100 – b * 10
                                           </pre>
                                            </td>
                                            <td>
                                                <pre>
a:= 6589;
b:= (a mod 100) + 45;
a:=(a*10) div 100 – b*10;

                                                </pre>
                                            </td>
                                            <td>
<pre>
a:=6589
b:= mod (a,100) + 45
a:=div((a*10),100) – b*10

</pre>
                                            </td>
                                        </tr>
                                        </tbody>
                                    </table>
                                </li>
                                <li>
                                    <div class="bold">Вариант 23</div>
                                    Определите значение целочисленных переменных a и b после выполнения фрагмента программы (ниже представлена одна и та же программа, записанная на разных языках программирования):
                                    <table class="practice-table" style="width: 100%;">
                                        <tbody>
                                        <tr>
                                            <th>Бейсик</th>
                                            <th>Паскаль</th>
                                            <th>Алгоритмический</th>
                                        </tr>
                                        <tr>
                                            <td>
                                                <pre>
a=3569
b=(a MOD 1000) – (a\100)
a=(b+a) MOD 1000

                                                </pre>
                                            </td>
                                            <td>
                                                <pre>
a:= 3569;
b:= (a mod 1000) – (a div 100);
a:= (b+a) mod 1000;

                                                </pre>
                                            </td>
                                            <td>
<pre>
a:=3569
b:= mod (a,1000) – div (a, 100);
a:= mod (b+a,1000)

</pre>
                                            </td>
                                        </tr>
                                        </tbody>
                                    </table>
                                </li>
                                <li>
                                    <div class="bold">Вариант 24</div>
                                    Определите значение целочисленных переменных a и b после выполнения фрагмента программы (ниже представлена одна и та же программа, записанная на разных языках программирования):
                                    <table class="practice-table" style="width: 100%;">
                                        <tbody>
                                        <tr>
                                            <th>Бейсик</th>
                                            <th>Паскаль</th>
                                            <th>Алгоритмический</th>
                                        </tr>
                                        <tr>
                                            <td>
                                                <pre>
a =4321
b =(a \ 1000) * 77
a= (b MOD 10) + a

                                                </pre>
                                            </td>
                                            <td>
                                                <pre>
a:= 4321;
b:= (a div 1000) *77;
a:= (b mod 10) + a;

                                                </pre>
                                            </td>
                                            <td>
<pre>
a:=4321
b:=div (a,1000) * 77
a:= mod (b,10) + a

</pre>
                                            </td>
                                        </tr>
                                        </tbody>
                                    </table>
                                </li>
                                <li>
                                    <div class="bold">Вариант 25</div>
                                    Определите значение целочисленных переменных x, y, и t после выполнения фрагмента программы  (ниже представлена одна и та же программа, записанная на разных языках программирования):
                                    <table class="practice-table" style="width: 100%;">
                                        <tbody>
                                        <tr>
                                            <th>Бейсик</th>
                                            <th>Паскаль</th>
                                            <th>Алгоритмический</th>
                                        </tr>
                                        <tr>
                                            <td>
                                                <pre>
x =99
y =72
t = x
` MOD – стандартная операция, вычисляющая остаток от  деления нацело первого аргумента на второй
x=y MOD x
y=t

                                                </pre>
                                            </td>
                                            <td>
                                                <pre>
x:=99;
y:=72;
t:=x;
x:=y mod x;
{mod - стандартная операция, вычисляющая остаток от  деления нацело первого аргумента на второй}
y:=t;

                                                </pre>
                                            </td>
                                            <td>
<pre>
x:=99;
y:=72;
t:=x;
x:=mod (y,x); | mod -стандартная функция, вычисляющая остаток от  деления нацело первого аргумента на второй|
y:=t;

</pre>
                                            </td>
                                        </tr>
                                        </tbody>
                                    </table>
                                </li>
                                <li>
                                    <div class="bold">Вариант 26</div>
                                    Определите значение целочисленных переменных a, и b после выполнения фрагмента программы (ниже представлена одна и та же программа, записанная на разных языках программирования):
                                    <table class="practice-table" style="width: 100%;">
                                        <tbody>
                                        <tr>
                                            <th>Бейсик</th>
                                            <th>Паскаль</th>
                                            <th>Алгоритмический</th>
                                        </tr>
                                        <tr>
                                            <td>
                                                <pre>
a =68
b =13
a = a\b
b = a*b
a = b\a
\ - стандартная операция, вычисляющая результат деления нацело первого аргумента на второй

                                                </pre>
                                            </td>
                                            <td>
                                                <pre>
a:=68;
b:=13;
a:=a div b;
b:=a*b;
a:=b div a;
{div - стандартная операция, вычисляющая результат деления нацело первого аргумента на второй }

                                                </pre>
                                            </td>
                                            <td>
<pre>
a:=68
b:=13
a:=div(a, b)
b:=a*b
a:=div(b, a)
| div - стандартная функция, вычисляющая результат деления нацело первого аргумента на второй |

</pre>
                                            </td>
                                        </tr>
                                        </tbody>
                                    </table>
                                </li>
                                <li>
                                    <div class="bold">Вариант 27</div>
                                    Определите значение целочисленных переменных a и b после выполнения фрагмента программы (ниже представлена одна и та же программа, записанная на разных языках программирования):
                                    <table class="practice-table" style="width: 100%;">
                                        <tbody>
                                        <tr>
                                            <th>Бейсик</th>
                                            <th>Паскаль</th>
                                            <th>Алгоритмический</th>
                                        </tr>
                                        <tr>
                                            <td>
                                                <pre>
a = 13+ 27 * 6
b = (a \10) + 41
a = (b MOD 10) + 11
\ и MOD - операции, вычисляющие результат деления нацело первого аргумента на второй и остаток от деления соответственно

                                                </pre>
                                            </td>
                                            <td>
                                                <pre>
a:= 13+ 27 * 6;
b:= (a div 10) + 41;
a:= (b mod 10) + 11;
{div и mod - операции, вычисляющие результат деления нацело первого аргумента на второй и остаток от деления соответственно }

                                                </pre>
                                            </td>
                                            <td>
<pre>
a:= 13+ 27 * 6
b:= div (a,10) + 41;
a:= mod (b,10) + 11
| div и mod - функции, вычисляющие результат деления нацело первого аргумента на второй и остаток от деления соответственно |

</pre>
                                            </td>
                                        </tr>
                                        </tbody>
                                    </table>
                                </li>
                                <li>
                                    <div class="bold">Вариант 28</div>
                                    Определите значение целочисленных переменных b и c после выполнения фрагмента программы (ниже представлена одна и та же программа, записанная на разных языках программирования):
                                    <table class="practice-table" style="width: 100%;">
                                        <tbody>
                                        <tr>
                                            <th>Бейсик</th>
                                            <th>Паскаль</th>
                                            <th>Алгоритмический</th>
                                        </tr>
                                        <tr>
                                            <td>
                                                <pre>
a =37
b =a MOD 10
c= a\10
\ - стандартная операция, вычисляющая результат деления нацело первого аргумента на второй

                                                </pre>
                                            </td>
                                            <td>
                                                <pre>
a:= 37;
b:= a MOD 10;
c:=a div 10;
{div - стандартная операция, вычисляющая результат деления нацело первого аргумента на второй }

                                                </pre>
                                            </td>
                                            <td>
<pre>
a:=37
b:= mod (a,10);
c:=div(a,10);
|div - стандартная функция, вычисляющая результат деления нацело первого аргумента на второй |

</pre>
                                            </td>
                                        </tr>
                                        </tbody>
                                    </table>
                                </li>
                                <li>
                                    <div class="bold">Вариант 29</div>
                                    Определите значение целочисленных переменных a и b после выполнения фрагмента программы (ниже представлена одна и та же программа, записанная на разных языках программирования):
                                    <table class="practice-table" style="width: 100%;">
                                        <tbody>
                                        <tr>
                                            <th>Бейсик</th>
                                            <th>Паскаль</th>
                                            <th>Алгоритмический</th>
                                        </tr>
                                        <tr>
                                            <td>
                                                <pre>
a =2684
b =(a \ 1000) * 111
a= (b MOD 10) + a

                                                </pre>
                                            </td>
                                            <td>
                                                <pre>
a:= 2684;
b:= (a div 1000) *111;
a:= (b mod 10) + a;

                                                </pre>
                                            </td>
                                            <td>
<pre>
a:=2684
b:=div (a,1000) * 111
a:= mod (b,10) + a

</pre>
                                            </td>
                                        </tr>
                                        </tbody>
                                    </table>
                                </li>
                                <li>
                                    <div class="bold">Вариант 30</div>
                                    Определите значение целочисленных переменных x, y, и t после выполнения фрагмента программы  (ниже представлена одна и та же программа, записанная на разных языках программирования):
                                    <table class="practice-table" style="width: 100%;">
                                        <tbody>
                                        <tr>
                                            <th>Бейсик</th>
                                            <th>Паскаль</th>
                                            <th>Алгоритмический</th>
                                        </tr>
                                        <tr>
                                            <td>
                                                <pre>
x =66
y =19
t = x
` MOD – стандартная операция, вычисляющая остаток от  деления нацело первого аргумента на второй
x=y MOD x
y=t

                                                </pre>
                                            </td>
                                            <td>
                                                <pre>
x:=66;
y:=19;
t:=x;
x:=y mod x;
{mod - стандартная операция, вычисляющая остаток от  деления нацело первого аргумента на второй}
y:=t;

                                                </pre>
                                            </td>
                                            <td>
<pre>
x:=66;
y:=19;
t:=x;
x:=mod (y,x); | mod -стандартная функция, вычисляющая остаток от  деления нацело первого аргумента на второй|
y:=t;
</pre>
                                            </td>
                                        </tr>
                                        </tbody>
                                    </table>
                                </li>

                            </ul>

                        </div>
                    </div>
                </article>

                <article class="content__item">
                    <span class="category category--full">Практическое занятие №2</span>

                    <h2 class="title title--full">Машина Поста</h2>

                    <div class="practice-title">
                        <p class="proved right">УТВЕРЖДЕНО</p>

                        <p class="date right">«&nbsp;&nbsp;» ________ 2015 г.</p>

                        <p class="date-sub right">Дата</p>

                        <p class="discipline center">Дисциплина: Теория алгоритмов </p>

                        <h2 class="center">Практическое занятие № 2</h2>

                        <p class="center">Наименование: Машина Поста</p>

                        <p class="spec indent">по специальности:</p>

                        <p class="spec indent">09.02.03 – Программирование в компьютерных системах</p>

                        <p class="spec indent">Количество часов <u>2</u></p>

                        <p class="new-part indent">РАССМОТРЕНО</p>

                        <p class="indent">на заседании цикловой комиссии <u>Информационные системы и технологии</u></p>

                        <p class="comission indent">наименование П(Ц)К</p>

                        <p class="indent">Председатель ____________<u>/ Шомас Е.А. /</u></p>

                        <p class="sign indent">подпись <span>расшифровка подписи</span></p>

                        <p class="indent">Протокол __________ от «&nbsp;&nbsp;» <u>04</u> 2015 г.</p>

                        <p class="protocol indent">номер <span>дата</span></p>

                        <p class="right">Составил преподаватель</p>

                        <p class="right">Пронина Т.С.</p>

                        <p class="center">Самара, КС ПГУТИ, 2015</p>
                    </div>

                    <div class="practice-info">
                        <p class="center bold">Практическое занятие №2</p>
                        <ol>
                            <li><span class="bold">Наименование</span>: Машина Поста</li>
                            <li><span class="bold">Цель занятия</span>: Изучить применение машины Поста к словам</li>
                            <li><span class="bold">Подготовка к занятию</span>:
                                <ol>
                                    <li>Кем и когда была предложена машина Поста?</li>
                                    <li>Существует ли реально машина Поста?</li>
                                    <li>Что представляет собой машина Поста?</li>
                                    <li>Каковы функции головки машины Поста?</li>
                                    <li>Какую структуру имеют команды машины Поста?</li>
                                </ol>
                            </li>
                            <li><span class="bold">Литература</span>:
                                <ol>
                                    <li>Конспект лекций по учебной дисциплине «Теория алгоритмов»</li>
                                    <li>Приложение к практическому занятию №2</li>
                                </ol>
                            </li>
                            <li><span class="bold">Перечень используемых материалов</span>:
                                <ol>
                                    <li>Канцелярские принадлежности</li>
                                    <li>Описание практического занятия</li>
                                </ol>
                            </li>
                            <li>
                                <span class="bold">Задание на занятие:</span>:
                                <div>Решить задачи:</div>
                                <ol>
                                    <li>Составить программу перевода информационной ленты машины Поста из начального
                                        состояния в конечное:
                                        <div><img src="img/practices/2/1.png" alt=""/></div>
                                    </li>
                                    <li>
                                        <ol>
                                            <li>Выполнить на машине Поста программу:
                                                <div><img src="img/practices/2/2.png" alt=""/></div>
                                            </li>
                                            <li>
                                                Какую задачу решает исполнитель по этой программе?
                                            </li>
                                            <li>
                                                Что произойдет, если начальное состояние информационной ленты имеет вид:
                                                <div><img src="img/practices/2/3.png" alt=""/></div>

                                            </li>
                                        </ol>
                                    </li>
                                    <li>На информационной ленте машины Поста помечены метками N клеток подряд. Каретка
                                        располагается под самой левой помеченной клеткой. Какой вид будет иметь
                                        информационная лента после окончания работы исполнителя по программе?
                                        <div><img src="img/practices/2/4.png" alt=""/></div>
                                    </li>
                                    <li>Написать для машины Поста программу сложения двух чисел, записанных на ленте, и
                                        расположенных через одну пустую клетку друг от друга. Начальное положение
                                        каретки под пустой клеткой, отделяющей числа.
                                    </li>
                                </ol>

                            </li>
                            <li><span class="bold">Порядок выполнения работы</span>:
                                <ol>
                                    <li>Получите допуск к занятию</li>
                                    <li>Решите задачи в соответствии с заданием</li>
                                    <li>Сдайте зачет</li>
                                </ol>
                            </li>
                            <li><span class="bold">Содержание отчета</span>:
                                <div class="italic">Решение задач в соответствии с п. 6.1 - 6.4 /div>
                                    <div class="italic">Ответы на контрольные вопросы.</div>
                            </li>
                            <li><span class="bold">Контрольные вопросы</span>:
                                <ol>
                                    <li>Сколько команд может выполнить машина Поста?</li>
                                    <li>Как организовать цикл на машине Поста?</li>
                                    <li>Каковы причины остановки машины Поста?</li>

                                </ol>
                            </li>
                        </ol>
                        <div class="work-done-by">
                            <span>Работу составил преподаватель</span>
                            <span class="right-float">Пронина Т.С.</span>
                        </div>
                    </div>
                    <div class="additional">
                        <p class="center bold">Приложение к практическому занятию №2</p>

                        <div>Абстрактная модель Поста представляет собой бесконечную ленту, разделённую на одинаковые
                            клетки, каждая из которых может быть либо пустой, либо заполненной меткой
                            <img src="img/practices/2/5.png" alt=""/> и головки <img src="img/practices/2/6.png"
                                                                                     alt=""/> , которая может:
                        </div>
                        <ul>
                            <li>1) Перемещаться вдоль ленты на одну клетку вправо или влево.</li>
                            <li>2) Наносить в клетку ленты метку, если этой метки там ранее не было.</li>
                            <li>3) Стирать метку, если она была.</li>
                            <li>4) Проверять наличие в клетке метки.</li>
                            <li>5) Останавливаться.</li>
                        </ul>
                        <div>Информация о заполненных метками клетках ленты характеризует состояние ленты, которое может
                            меняться в процессе работы машины. В каждый момент времени головка <img
                                    src="img/practices/2/6.png"
                                    alt=""/> находится над одной
                            из клеток ленты и, как говорят, обозревает ее. Информация о местоположении головки вместе с
                            состоянием ленты характеризует состояние машины Поста, (рис 1.)
                            <div><img src="img/practices/2/7.png"
                                      alt=""/></div>
                        </div>
                        <div>Команда машины Поста имеет следующую структуру:</div>
                        <div>nKm</div>
                        <div>где: n –порядковый номер команды;</div>
                        <div>K-действие, выполняемое головкой;</div>
                        <div>m – номер следующей команды, подлежащей выполнению.</div>
                        Перечень возможных команд и состояние ленты отображены
                        в таблице
                        <table class="practice-table" style="width: 100%;">
                            <tbody>
                            <tr>
                                <th>Команда</th>
                                <th>Состояние ленты</th>
                            </tr>
                            <tr>
                                <td>Движение головки на одну клетку вправо</td>
                                <td><img src="img/practices/2/8.png"
                                         alt=""/></td>
                            </tr>
                            <tr>
                                <td>Движение головки на одну клетку влево</td>
                                <td><img src="img/practices/2/9.png"
                                         alt=""/></td>
                            </tr>
                            <tr>
                                <td>Нанесение метки в клетку,
                                    над которой находится головка
                                </td>
                                <td><img src="img/practices/2/10.png"
                                         alt=""/></td>
                            </tr>
                            <tr>
                                <td>Стирание метки из клетки,
                                    над которой находится головка
                                </td>
                                <td><img src="img/practices/2/11.png"
                                         alt=""/></td>
                            </tr>
                            <tr>
                                <td>Проверка наличия метки в клетке,
                                    над которой находится головка;
                                </td>
                                <td><img src="img/practices/2/12.png"
                                         alt=""/></td>
                            </tr>
                            <tr>
                                <td>Остановка машины</td>
                                <td><img src="img/practices/2/13.png"
                                         alt=""/></td>
                            </tr>
                            </tbody>
                        </table>
                        <div>Ситуации, в которых головка должна наносить метку там, где она уже имеется или, наоборот,
                            стирать метку там, где её нет, являются аварийными (недопустимыми).
                        </div>
                        <div>С точки зрения свойств алгоритмов, изучаемых с помощью машины Поста, наибольший интерес
                            представляют причины остановки машины при выполнении программы:
                        </div>
                        <ul>
                            <li>1) останов по команде «стоп»; такой останов называется результативным и указывает на
                                корректность алгоритма (программы);
                            </li>
                            <li>2) останов при выполнении недопустимой команды; в этом случае останов называется
                                безрезультативным;
                            </li>
                            <li>3) машина не останавливается никогда; в этом случае и в предыдущем случае мы имеем дело
                                с некорректным алгоритмом (программой).
                            </li>
                        </ul>
                        <div>Если не оговорено иначе, то будем понимать под начальным состояние головки против пустой
                            клетки левее самой левой метки на ленте.
                        </div>
                        <div>Рассмотрим реализацию некоторых типичных элементов программ машины Поста.</div>
                        <div>1 Пусть задано исходное состояние головки и требуется на пустой ленте написать две метки:
                            одну в секцию под головкой, вторую справа от неё. Это можно сделать по следующей программе
                            (справа от команды показан результат её выполнения):
                            <div><img src="img/practices/2/14.png"
                                      alt=""/></div>
                        </div>
                        <div>2 Для организации циклического процесса можно воспользоваться командной условного перехода.
                            Пусть на ленте имеется запись из нескольких меток подряд и головка находится над самой
                            крайней меткой справа. Требуется перевести головку влево до первой пустой позиции.
                        </div>
                        <div>Программа будет иметь следующий вид:
                            <div><img src="img/practices/2/15.png"
                                      alt=""/></div>
                        </div>
                        <div>Команда условного перехода является одним из основных средств организации циклических
                            процессов, например, для нахождения первой метки справа (или слева) от головки,
                            расположенной над пустой клеткой; нахождение слева (или справа) от головки пустой клетки,
                            если она расположена над меткой и т.д.
                        </div>
                        <div>3 Остановимся на представлении чисел на ленте машины Поста и выполнении операций над
                            ними.
                        </div>
                        <div>Число k представляется на ленте машины Поста идущими подряд k метками. Между двумя числами
                            делается интервал как минимум из одной пустой секции на ленте. Например, запись чисел 3 и 5
                            на ленте машины Поста будет выглядеть так:
                            <div><img src="img/practices/2/16.png"
                                      alt=""/></div>
                        </div>
                        <div>Обратим внимание, что используемая в машине Поста система записи чисел является
                            непозиционной.
                        </div>
                        <div>Составим программу для прибавления к произвольному числу единицы. Предположим, что на ленте
                            записано только одно число и головка находится над одной из клеток, в которой находится
                            метка, принадлежащая этому числу:
                            <div><img src="img/practices/2/17.png"
                                      alt=""/></div>
                        </div>
                        <div>Для решения задачи можно переместить головку влево (или вправо) до первой пустой клетки, а
                            затем нанести метку.
                        </div>
                        <div>Программа, добавляющая к числу метку слева, имеет вид(программа приведена в трёх разных
                            видах:
                            <div><img src="img/practices/2/18.png"
                                      alt=""/></div>
                        </div>
                        <div>Предположим, что головка расположена на расстоянии нескольких клеток слева от числа, к
                            которому
                            нужно прибавить единицу. В этом случае программа усложняется. Появиться «блок поиска числа»
                            -
                            две команды, приводящие головку в состояние, рассмотренное в предыдущем примере:
                            <div><img src="img/practices/2/19.png"
                                      alt=""/></div>
                        </div>
                        <div>Ниже – полные тексты программ, добавляющие единицу слева и справа, соответственно:
                            <div><img src="img/practices/2/20.png"
                                      alt=""/></div>
                        </div>
                        <div>В первом случае не нужно перемещать головку к крайней левой метке числа.</div>
                    </div>
                </article>

                <article class="content__item">
                    <span class="category category--full">Практическое занятие №3</span>

                    <h2 class="title title--full">Сортировка и поиск</h2>

                    <div class="practice-title">
                        <p class="proved right">УТВЕРЖДЕНО</p>

                        <p class="date right">«&nbsp;&nbsp;» ________ 2015 г.</p>

                        <p class="date-sub right">Дата</p>

                        <p class="discipline center">Дисциплина: Теория алгоритмов </p>

                        <h2 class="center">Практическое занятие № 3</h2>

                        <p class="center">Наименование: Сортировка и поиск</p>

                        <p class="spec indent">по специальности:</p>

                        <p class="spec indent">09.02.03 – Программирование в компьютерных системах</p>

                        <p class="spec indent">Количество часов <u>4</u></p>

                        <p class="right">Составил преподаватель</p>

                        <p class="right">Пронина Т.С.</p>

                        <p class="center">Самара, КС ПГУТИ, 2015</p>
                    </div>

                    <div class="practice-info">
                        <p class="center bold">Практическое занятие №3</p>
                        <ol>
                            <li><span class="bold">Наименование</span>: Сортировка и поиск</li>
                            <li><span class="bold">Цель занятия</span>: Изучить алгоритмы сортировки, поиска, вставки и
                                удаления.
                            </li>
                            <li><span class="bold">Подготовка к занятию</span>:
                                <ol>
                                    <li>Повторить тему: «Сортировка и поиск»</li>
                                    <li>Ответить на контрольные вопросы:
                                        <ol>
                                            <li>Укажите область применения бинарных деревьев</li>
                                            <li>Какой граф называется деревом?</li>
                                            <li>Верны ли следующие утверждения о связном ацикличном графе G = ( V, E) с
                                                n вершинами
                                                и m рёбрами:
                                                <ul>
                                                    <li>a) G – дерево</li>
                                                    <li>b) любую пару вершин G связывает единственный путь</li>
                                                    <li>c) G связан и m = n – 1</li>
                                                    <li>d) G связан , а удаление любого ребра нарушает связность</li>
                                                    <li>e) G ацикличен, но соединяя любую пару вершин новым ребром,
                                                        получим цикл
                                                    </li>
                                                    <li>f) Не в любом связном графе найдётся подграф являющийся дерево
                                                    </li>
                                                </ul>
                                            </li>
                                            <li>Какое дерево называют деревом с корнем?</li>
                                            <li>Что называется корнем?</li>
                                            <li>Что называется сыновьями вершины v?</li>
                                            <li>Что называется листьями?</li>
                                            <li>Что называется внутренними вершинами дерева?</li>
                                            <li>Чем является каждая вершина дерева с корнем T?</li>
                                            <li>Сколько сыновей имеет каждая вершина двоичного дерева с корнем?</li>
                                            <li>Какое двоичное дерево с корнем называется полным?</li>
                                            <li>Что называется глубиной вершины v дерева с корнем T?</li>
                                            <li>Что называется глубиной дерева?</li>
                                            <li>Какое дерево называется двоичным деревом поиска?</li>
                                            <li>Приведите примеры данных, которые необходимо упорядочить в
                                                вычислительных
                                                приложениях?
                                            </li>
                                            <li>В чём заключается преимущество организации данных, упорядоченных в виде
                                                двоичного
                                                дерева поиска?
                                            </li>
                                        </ol>
                                    </li>
                                </ol>
                            </li>
                            <li><span class="bold">Литература</span>:
                                <ol>
                                    <li>Конспект лекций по учебной дисциплине «Теория алгоритмов»</li>
                                    <li>Хаггарти Р. Дискретная математика для программистов М: Техносфера, 2012 – 320с
                                    </li>
                                    <li>Приложение к ПЗ</li>
                                </ol>
                            </li>
                            <li><span class="bold">Перечень используемых материалов</span>:
                                <ol>
                                    <li>Канцелярские принадлежности</li>
                                    <li>Бланк для отчёта</li>
                                </ol>
                            </li>
                            <li><span class="bold">Задание на занятие:</span>:
                                <ol>
                                    <li>
                                        Постройте бинарное дерево поиска использую перечень имён: Пётр, Дмитрий, Семён,
                                        Владимир,
                                        Сергей, Роман, Борис, Михаил, Ульяна, Лариса. В качестве вершины используйте:
                                        <ul>
                                            <li>а) имя Пётр</li>
                                            <li>б) имя Владимир</li>
                                        </ul>
                                        <div>Графически отобразите каждый этап построения.</div>
                                    </li>
                                    <li>Постройте бинарное дерево поиска слов фразы: «Бинарное дерево обеспечивает
                                        прекрасный метод
                                        организации данных, при котором любые конкретные данные легко найти, или
                                        установить их
                                        отсутствие».
                                    </li>
                                    <li>Рассмотрите дерево поиска (см. рис. 1)
                                        <div><img src="img/practices/3/1.png"
                                                  alt=""/></div>
                                        Удалите вершины:
                                        <ol>
                                            <li>x</li>
                                            <li>k</li>
                                            <li>h</li>
                                            <li>p</li>
                                        </ol>
                                    </li>
                                    <li>Задано дерево (см. рис. п 6.3). Сколько потребуется сравнений для определения
                                        того, что
                                        отсутствует буква:
                                        <ol>
                                            <li>j</li>
                                            <li>u</li>
                                            <li>f</li>
                                        </ol>
                                    </li>
                                    <li>
                                        На заданном дереве (см. п. 6.3) (см. рис. 1) вставьте буквы:
                                        <ol>
                                            <li>j</li>
                                            <li>u</li>
                                            <li>m</li>
                                        </ol>
                                    </li>
                                </ol>
                            </li>
                            <li><span class="bold">Порядок проведения занятия:</span>:
                                <ol>
                                    <li>Получите допуск к занятию</li>
                                    <li>Выполните п. 6.1 – 6.6</li>
                                    <li>Оформите отчёт</li>
                                    <li>Сдайте отчёт преподавателю и получите зачёт</li>
                                    <li>В случае успешной сдачи зачёта получите задание у преподавателя из вариативной
                                        части и
                                        выполните его
                                    </li>
                                </ol>
                            </li>
                            <li><span class="bold">Содержание отчета</span>:
                                <div class="italic">Решение задач 6.1 – 6.6 с требуемыми пояснениями</div>
                            </li>
                            <li><span class="bold">Контрольные вопросы</span>:
                                <ol>
                                    <li>На приведённом дереве (см. рис.2)
                                        <div><img src="img/practices/3/2.png"
                                                  alt=""/></div>
                                        Найдите:
                                        <ul>
                                            <li>1 корень дерева</li>
                                            <li>2 корень левого поддерева вершины B</li>
                                            <li>3 листья дерева</li>
                                            <li>4 сыновей вершины C</li>
                                        </ul>
                                        Укажите правило поиска требуемой информации в бинарном дереве поиска.
                                    </li>
                                </ol>
                            </li>
                        </ol>
                        <div class="work-done-by">
                            <span>Работу составил преподаватель</span>
                            <span class="right-float">Пронина Т.С.</span>
                        </div>
                    </div>
                    <div class="additional">
                        <p class="center bold">Приложение к практическому занятию №3</p>

                        <div>Двоичные деревья с корнем очень полезны при решении задач о выборе, в частности, о выборе
                            такого сорта, при котором нужно классифицировать упорядоченные данные или вести в них поиск.
                        </div>
                        <div>Упорядоченные данные, такие как множество чисел, упорядоченных по величине или множество
                            строк литер, упорядоченных лексикографически (в алфавитном порядке), можно организовать в
                            виде вершин двоичного дерева с корнем в соответствии с их порядком. При этом мы стремимся к
                            тому, чтобы данные, стоящие в левом поддереве данной вершины v были бы меньше данных,
                            соответствующих этой вершине, а данные, расположенные в правом ее поддереве – больше. Дерево
                            данных, удовлетворяющее указанному условию, называют двоичным деревом поиска.
                        </div>
                        <div>Например, в дереве двоичного поиска, приведенном на рис. 3 , слова фразы «У МОЕГО
                            КОМПЬЮТЕРА ЕСТЬ ЧИП НА МАТЕРИНСКОЙ ПЛАТЕ» организованы именно таким образом. Заметим, что
                            каждое слово в левом поддереве любой вершины предшествует (относительно алфавитного порядка)
                            слову, стоящему в этой вершине, а каждое слово ее правого поддерева следует за словом
                            выбранной вершины.
                            <div><img src="img/practices/3/3.png"
                                      alt=""/></div>
                        </div>
                        <div>Преимущество организации упорядоченных данных в виде двоичного дерева поиска заключается в
                            возможности создания эффективного алгоритма поиска каких-то конкретных данных, включения
                            новых данных в дерево и печати всей информации, содержащейся в дереве в виде упорядоченного
                            списка.
                        </div>
                        <div>Предположим, что в университете хранится список студентов (упорядоченный в алфавитном
                            порядке), в котором кроме фамилий и имён имеются дополнительные важные сведения о студентах.
                            Допустим также, что возникла необходимость найти какую-то информацию в списке или добавить
                            новые записи к списку. Мы познакомимся с алгоритмами, которые осуществляют поиск конкретной
                            информации, добавляют новых студентов к списку и выводят на печать все записи в алфавитном
                            порядке.
                        </div>
                        <div>Записи о студентах организованы в двоичное дерево поиска (каждая запись соответствует одной
                            вершине), и наши алгоритмы будут исследовать вершины этого дерева. Поскольку каждая вершина
                            является также и корнем некоторого двоичного дерева поиска, алгоритмы будут последовательно
                            проверять левые и правые поддеревья вершин. Чтобы это осуществить, необходимо приписать
                            каждой вершине некоторый ключ для идентификации и ссылок на ее левое и правое поддеревья (в
                            структурах данных для этих целей используются так называемые дважды связанные списки). Из
                            всех ключей организуется линейно упорядоченное множество (в нашей ситуации оно упорядочено
                            лексикографически).
                        </div>
                        <div><span class="bold italic">Алгоритм поиска</span> определяет, является ли данная запись
                            (ключ поиска) вершиной в двоичном дереве поиска, сравнивая ключ поиска с ключом корня
                            дерева, и, при необходимости, осуществляет аналогичные сравнения в левом или правом
                            поддеревьях.
                        </div>
                        <div>
                            <div class="bold">Поиск (дерево)</div>
                            <pre>
     begin
         if дерево нулевое then
             поиск := ложь;
         else
                if ключ поиска = ключ корня then
                    поиск := истина;
                else
                       If ключ поиска < ключ корня then
                           поиск := поиск (левое поддерево);
                       else
                            поиск := поиск (правое поддерево);
     end
                            </pre>
                        </div>
                        <div><span class="bold">Пример 1</span> Проследите за работой алгоритма над двоичным деревом
                            поиска, изображенном на рис.4. Известно, что ключ поиска – буква R, а ключи вершин
                            упорядочены лексикографически.
                        </div>
                        <div><span class="bold">Решение.</span> Поскольку R > K, то поиск продолжается в правом
                            поддереве вершины K. так как R < T, процесс поиска переключается на левое поддерево вершины
                            T. Наконец, ввиду неравенства R ≠ M и отсутствия поддеревьев у вершины M, алгоритм
                            заканчивается и сообщает, что искомая вершина не была найдена.
                            <div><img src="img/practices/3/4.png"
                                      alt=""/></div>
                        </div>
                        <div><span class="bold italic">Алгоритм вставки</span> вставляет новые вершины (ключи вставок) в
                            двоичное дерево поиска, создавая при этом новую вершину слева или справа от уже
                            существующей. Это делается таким образом, чтобы все ключи вершин в получившемся дереве
                            подчинялись установившемуся порядку.
                        </div>
                        <div>
                            <div class="bold">Вставка (запись, дерево)</div>
                            <pre>
             begin
                 if   дерево нулевое then
                        добавить новую вершину;
                 else
                        if ключ вставки = ключ корня then
                             вывести на печать:
                             «запись содержится в дереве»;
                        else
                               if ключ вставки < ключ корня then
                        вставка := вставка (запись, левое поддерево);
                               else
                         вставка := вставка (запись, правое поддерево);
         end

                            </pre>
                        </div>
                        <div><span class="bold">Пример 2</span> Проследите за работой алгоритма вставки на примере
                            вершин R, A и L в дерево из примера 1.
                        </div>
                        <div><span class="bold">Решение.</span> Поскольку R > K, мы применяем алгоритм вставки к правому
                            поддереву вершины K. Далее мы видим, что R < T. Значит, алгоритм вставки переключается на
                            левое поддерево вершины T. Так как R > M и правое поддерево вершины M нулевое, то мы ставим
                            вершину R справа от M и получаем дерево, изображенное на рис.5.
                            <div><img src="img/practices/3/5.png"
                                      alt=""/></div>
                        </div>
                        <div>Теперь вставим A и L, построив дерево, показанное на рис. 6</div>
                        <div><img src="img/practices/3/6.png"
                                  alt=""/></div>
                        <div>Алгоритм вставки можно использовать для создания двоичного дерева поиска, начиная с
                            нулевого дерева и последовательного добавляя новые данные в удобном для нас порядке.
                            Например, двоичное дерево поиска на рис. 1 является результатом применения алгоритма вставки
                            к нулевому дереву в процессе добавления слов фразы «У МОЕГО КОМПЬЮТЕРА ЕСТЬ ЧИП НА
                            МАТЕРИНСКОЙ ПЛАТЕ» в том порядке, в котором они в ней записаны.
                        </div>
                        <div><span class="italic">Алгоритм правильного обхода</span> выводит на печать всю информацию,
                            содержащуюся в двоичном дереве поиска, в надлежащем порядке. При этом все вершины дерева
                            осматриваются в определенном порядке. Алгоритм работает следующим образом. Для каждой
                            вершины, начиная с корня, печатается вся информация, содержащаяся в вершинах следующим
                            образом. Для каждой вершины, начиная с корня, печатается вся информация, хранящаяся в этой
                            вершине, и наконец, информация, соответствующая вершинам правого поддерева.
                        </div>
                        <div>
                            <div class="bold">Правильный обход (дерево)</div>
                            <pre>
             begin
                 if дерево нулевое then
                    ничего не делать;
                 else
                            begin
                                       правильный обход (левое поддерево);
                                       напечатать корневой ключ;
                                       правильный обход (правое поддерево);
                           end
            end


                            </pre>
                        </div>
                        <div><span class="bold">Пример 3</span> Примените алгоритм правильного обхода к дереву,
                            полученному в примера 2 после вставки R, A и L.
                        </div>
                        <div><span class="bold">Решение.</span> После работы алгоритма над указанным деревом получается
                            список:
                            <div>A, C, K, L, M, R, T, V.</div>
                            Он соответствует обходу дерева против часовой стрелки (рис. 7) и печати информации,
                            содержащейся в вершинах, как только Вы прошли под вершиной.
                            <div><img src="img/practices/3/7.png"
                                      alt=""/></div>
                        </div>
                        <div class="work-done-by">
                            <span>Работу составил преподаватель</span>
                            <span class="right-float">Пронина Т.С.</span>
                        </div>
                    </div>
                </article>

                <article class="content__item">
                    <span class="category category--full">Практическое занятие №4</span>

                    <h2 class="title title--full">Задача коммивояжера. Алгоритм ближайшего соседа</h2>

                    <div class="practice-title">
                        <p class="proved right">УТВЕРЖДЕНО</p>

                        <p class="date right">«&nbsp;&nbsp;» ________ 2015 г.</p>

                        <p class="date-sub right">Дата</p>

                        <p class="discipline center">Дисциплина: Теория алгоритмов</p>

                        <h2 class="center">Практическое занятие № 4</h2>

                        <p class="center">Наименование: Задача коммивояжера. Алгоритм ближайшего соседа</p>

                        <p class="spec indent">по специальности:</p>

                        <p class="spec indent">09.02.03 – Программирование в компьютерных системах</p>

                        <p class="spec indent">Количество часов <u>2</u></p>

                        <p class="right">Составил преподаватель</p>

                        <p class="right">Пронина Т.С.</p>

                        <p class="center">Самара, КС ПГУТИ, 2015</p>
                    </div>
                    <div class="practice-info">
                        <p class="center bold">Практическое занятие №4</p>
                        <ol>
                            <li><span class="bold">Наименование</span>: Задача коммивояжера. Алгоритм ближайшего соседа
                            </li>
                            <li><span class="bold">Цель занятия</span>: Научиться практически применять алгоритм
                                ближайшего соседа для нахождения субоптимального решения задачи коммивояжера
                            </li>
                            <li><span class="bold">Подготовка к занятию</span>:
                                <ol>
                                    <li>Повторить тему «Алгоритм ближайшего соседа»</li>
                                    <li>Ответить на вопросы для допуска к работе:
                                        <ol>
                                            <li>Что называется гамильтоновым графом?</li>
                                            <li>Какие модели можно построить на основе гамильтоновых графов?</li>
                                            <li>Существует ли простой критерий гамильтоновости графа?</li>
                                            <li>Какой граф называется полным?</li>
                                            <li>Существует ли в любом полном графе гамильтонов цикл?</li>
                                            <li>Как обозначается полный граф?</li>
                                            <li>Как зависит число гамильтоновых циклов в полном графе от числа его
                                                вершин?
                                            </li>
                                            <li>В чем заключается смысл задачи коммивояжера?</li>
                                            <li>Укажите затраты, которые должны быть сведены к минимуму при решении
                                                задачи коммивояжера
                                            </li>
                                            <li>Что представляет собой графическая модель задачи коммивояжера?</li>
                                            <li>Какое решение задачи коммивояжера можно получить с помощью алгоритма
                                                ближайшего соседа?
                                            </li>
                                            <li>Сколько гамильтоновых циклов существует в полном графе с двадцатью
                                                вершинами?
                                            </li>
                                        </ol>
                                    </li>
                                </ol>
                            </li>
                            <li><span class="bold">Литература</span>:
                                <ol>
                                    <li>Рхаггарти. Дискретная математика для программистов М. Техносфера. 2012 – 320
                                        с.
                                    </li>
                                    <li>Конспект лекций по учебной дисциплине «Теория алгоритмов»</li>
                                    <li>Приложение к практическому занятию №4</li>
                                </ol>
                            </li>
                            <li><span class="bold">Перечень используемых материалов</span>:
                                <ol>
                                    <li>Канцелярские принадлежности</li>
                                    <li>Бланк для отчета</li>
                                </ol>
                            </li>
                            <li><span class="bold">Задание на занятие:</span>:
                                <ol>
                                    <li>Используйте алгоритм ближайшего соседа для поиска гамильтонова цикла в
                                        нагруженном графе, взяв за исходную:
                                        <div>(а) вершину А;</div>
                                        <div>(б) вершину D.</div>
                                        <div><img src="img/practices/4/1.png"
                                                  alt=""/></div>
                                    </li>
                                    <li><span class="bold">Вариативная часть:</span>
                                        <ol>
                                            <li>Найдите гамильтоновы циклы в графе на рис. 2.
                                                <div><img src="img/practices/4/2.png"
                                                          alt=""/></div>
                                                Найдите в нем циклы длины 3, 4, 5, 6 и 7.
                                            </li>
                                            <li>Найдите в графе Петерсена рис. 3, цикл длины 9. Покажите, что граф не
                                                является гамильтоновым.
                                                <div><img src="img/practices/4/3.png"
                                                          alt=""/></div>
                                            </li>
                                        </ol>
                                    </li>
                                </ol>
                            </li>
                            <li><span class="bold">Порядок выполнения работы</span>:
                                <ol>
                                    <li>Получите допуск работе</li>
                                    <li>Выполните задание пункта 6</li>
                                    <li>Оформите отчет, сдайте его преподавателю</li>
                                    <li>В случае успешной сдачи зачета выполните пункт 6.2 (вариативную часть)</li>
                                </ol>
                            </li>
                            <li><span class="bold">Содержание отчета</span>:
                                <div class="italic">Решение задач в соответствии с заданиями</div>
                            </li>
                            <li><span class="bold">Контрольные вопросы</span>:
                                <ol>
                                    <li>Какая вершина выбирается первой при использовании алгоритма ближнего соседа?
                                    </li>
                                    <li>Какая вершина выбирается в качестве второй при использовании алгоритма ближнего
                                        соседа?
                                    </li>
                                    <li>Изменится ли решение задачи коммивояжера, если вместо первой вершины графа взять
                                        любую другую?
                                    </li>
                                    <li>Каким путем можно найти количество всех гамильтоновых циклов при использовании
                                        алгоритма ближайшего соседа?
                                    </li>
                                </ol>
                            </li>
                        </ol>
                        <div class="work-done-by">
                            <span>Работу составил преподаватель</span>
                            <span class="right-float">Пронина Т.С.</span>
                        </div>
                    </div>
                    <div class="additional">
                        <p class="center bold">Приложение к практическому занятию №4</p>

                        <div>Цикл, проходящий через каждую вершину в точности один раз, называется <span class="italic">гамильтоновым</span>,
                            а соответствующий граф – <span class="italic">гамильтоновым графом</span> .
                        </div>
                        <div>Гамильтоновы графы служат моделью при составлении расписания движения поездов, для
                            телекоммуникационных сетей, и т.д. В отличии от графа Эйлера, простого критерия
                            гамильтоновости графа пока неизвестно. Поиск хорошего критерия остается одной из главных
                            нерешенных задач теории графов.
                        </div>
                        <div>Тем не менее, многие графы являются гамильтоновыми. Предположим, что в каком-то графе любая
                            пара вершин соединена ребром. Такой граф называется <span class="italic">полным</span> и
                            обозначается через Кn, где n – число его вершин. Очевидно, в любом полном графе можно
                            отыскать гамильтонов цикл.
                        </div>
                        <div>Полный граф К5 изображен на рис. 4. Его цикл A B C D E, является гамильтоновым. В нем есть
                            и другие гамильтоновы циклы. Поскольку каждая вершина смежна с остальными, то начиная с
                            вершины A, в качестве второй вершины цикла мы можем выбрать любую из четырех оставшихся.
                            Далее у нас будет три варианта для выбора третей вершины и два для четвертой, после чего мы
                            вернемся в вершину А. Таким образом у нас есть 4*3*2=24 цикла. Поскольку каждый цикл можно
                            проходить как в одном направлении, так и в другом, то реально в графе К5, есть только 12
                            разных гамильтоновых циклов. Две разные последовательности вершин: A B C D E A и A E D C B A
                            задают, очевидно, один и тот же цикл.
                        </div>
                        <div><img src="img/practices/4/4.png"
                                  alt=""/></div>
                        <div>Поиск гамильтонова цикла (если он существует) в произвольном (связном) графе – задача
                            далеко не всегда простая.
                        </div>
                        <div><span class="bold">Пример 1.</span> Покажите, что граф, изображенный на рис. 5, не является
                            гамильтоновым.
                        </div>
                        <div><img src="img/practices/4/5.png"
                                  alt=""/></div>
                        <div><span class="bold">Решение</span>. Предположим, что в связном графе найдется гамильтонов
                            цикл. Каждая вершина υ включается в гамильтонов цикл С выбором двух инцидентных с ней ребер,
                            а значит, степень каждой вершины в гамильтоновом цикле (после удаления лишних ребер) равна
                            2. Степени вершин данного графа – 2 или 3. Вершины степени 2 входят в цикл вместе с обоими
                            инцидентными с ними ребрами. Следовательно, ребра ab, ae, cd, cb, hi, hg и ij в том или ином
                            порядке входят в гамильтонов цикл С (см. рис. 6).
                        </div>
                        <div>Ребро bf не может быть частью цикла С, поскольку каждая вершина такого цикла должна иметь
                            степень 2. Значит, ребра fj и fg обязаны входить в цикл С, чтобы включить в него вершину f.
                            Но тогда ребра fe и gd никак не могут принадлежать циклу С, поскольку в противном случае в
                            нем появятся вершины степени три. Это вынуждает нас включить в цикл ребро ed, что приводит
                            нас к противоречию: ребра, которые мы были вынуждены выбрать, образуют два несвязных цикла,
                            а не один, существование которого мы предполагали. Вывод: граф, изображенный на рис. 6, не
                            является гамильтоновым.
                        </div>
                        <div><img src="img/practices/4/6.png"
                                  alt=""/></div>
                        <div>Гамильтоновы графы применяются для моделирования многих практических задач. Основой всех
                            таких задач служит классическая <span class="italic">задача коммивояжера.</span></div>
                        <div class="italic">Коммивояжер должен совершить поездку по городам и вернуться обратно, побывав
                            в каждом городе ровно один раз, сведя при этом затраты на передвижения к минимуму.
                        </div>
                        <div>Графическая модель задачи коммивояжера состоит из гамильтонова графа, вершины которого
                            изображают города, а ребра – связывающие их дороги. Кроме того, каждое ребро оснащено весом,
                            обозначающим транспортные затраты, необходимые для путешествия по соответствующей дороге,
                            такие, как, например, расстояние между городами или время движения по дороге. Для решения
                            задачи нам необходимо найти гамильтонов цикл минимального общего веса.
                        </div>
                        <div>К сожалению, эффективный алгоритм решения данной задачи пока не известен. Для сложных сетей
                            число гамильтоновых циклов, которые необходимо просмотреть для выделения минимального,
                            непомерно огромно. Однако существуют алгоритмы поиска <span class="italic">субоптимального решения</span>
                            .
                        </div>
                        <div>Субоптимальное решение не обязательно даст цикл минимального общего веса, но найденный цикл
                            будет, как правило, значительно меньшего веса, чем большинство произвольных гамильтоновых
                            циклов.
                        </div>
                        <p class="bold">Алгоритм ближайшего соседа</p>

                        <div>Этот алгоритм выдает субоптимальное решение задачи коммивояжёра, генерируя гамильтоновы
                            циклы в нагруженном графе с множеством вершин V. Цикл, полученный в результате работы
                            алгоритма, будет совпадать с конечным значением переменной маршрута, а его общая длина —
                            конечное значение переменной ω.
                        </div>
                        <pre>
                            begin
            Выбрать v∈V;
            маршрут:=v;
            ω:=0;
            v^,≔v;
            Отметить v^,;
            while остаются неотмеченные вершины do
                begin
                    Выбрать неотмеченную вершину u,
                    ближайшую к  v^,;
                    маршрут :=маршрут u;
                    ω := ω + вес ребра v^,u;
                    v^,≔u;
                    Отметить v^,;
            end
            Маршрут := маршрут u;
            ω:= ω + вес ребра v^,u;
            end

                        </pre>
                        <div><span class="bold">Пример 2.</span> Примените алгоритм ближайшего соседа к графу,
                            изображенному на рис. 7. За исходную вершину возьмите вершину D.
                        </div>
                        <div><img src="img/practices/4/7.png"
                                  alt=""/></div>
                        <div><span class="bold">Решение.</span> Смотри табл. 1.</div>
                        <div>Таблица 1</div>
                        <table class="practice-table" style="width: 100%;">
                            <tbody>
                            <tr>
                                <th></th>
                                <th>u</th>
                                <th>маршрут</th>
                                <th>ω</th>
                                <th>v^</th>
                            </tr>
                            <tr>
                                <td>Исходные значения</td>
                                <td>-</td>
                                <td>D</td>
                                <td>0</td>
                                <td>D</td>
                            </tr>
                            <tr>
                                <td></td>
                                <td>C</td>
                                <td>DC</td>
                                <td>3</td>
                                <td>C</td>
                            </tr>
                            <tr>
                                <td></td>
                                <td>A</td>
                                <td>DCA</td>
                                <td>9</td>
                                <td>A</td>
                            </tr>
                            <tr>
                                <td></td>
                                <td>B</td>
                                <td>DCAB</td>
                                <td>14</td>
                                <td>B</td>
                            </tr>
                            <tr>
                                <td>Последний проход</td>
                                <td>B</td>
                                <td>DCABD</td>
                                <td>24</td>
                                <td>B</td>
                            </tr>
                            </tbody>
                        </table>
                        <div>В результате работы алгоритма был найден гамильтонов цикл D C A B D общего веса 24. Делая
                            полный перебор всех циклов в этом маленьком графе, можно обнаружить еще два других
                            гамильтоновых цикла: A B C D A общего веса 23 и A C B D A общего веса 31. В полном графе с
                            двадцатью вершинами существует приблизительно 6,1х1016 гамильтоновых циклов, перечисление
                            которых требует чрезвычайно много машинной памяти и времени.
                        </div>
                    </div>
                </article>

                <article class="content__item">
                    <span class="category category--full">Практическое занятие №5</span>

                    <h2 class="title title--full">Алгоритм поиска минимального остовного дерева</h2>

                    <div class="practice-title">
                        <p class="proved right">УТВЕРЖДЕНО</p>

                        <p class="date right">«&nbsp;&nbsp;» ________ 2015 г.</p>

                        <p class="date-sub right">Дата</p>

                        <p class="discipline center">Дисциплина: Теория алгоритмов</p>

                        <h2 class="center">Практическое занятие № 5</h2>

                        <p class="center">Наименование: Алгоритм поиска минимального остовного дерева</p>

                        <p class="spec indent">по специальности:</p>

                        <p class="spec indent">09.02.03 – Программирование в компьютерных системах</p>

                        <p class="spec indent">Количество часов <u>2</u></p>

                        <p class="new-part indent">РАССМОТРЕНО</p>

                        <p class="indent">на заседании цикловой комиссии <u>Информационные системы и технологии</u></p>

                        <p class="comission indent">наименование П(Ц)К</p>

                        <p class="indent">Председатель ____________<u>/ Шомас Е.А. /</u></p>

                        <p class="sign indent">подпись <span>расшифровка подписи</span></p>

                        <p class="indent">Протокол __________ от «&nbsp;&nbsp;» <u>04</u> 2015 г.</p>

                        <p class="protocol indent">номер <span>дата</span></p>

                        <p class="right">Составил преподаватель</p>

                        <p class="right">Пронина Т.С.</p>

                        <p class="center">Самара, КС ПГУТИ, 2015</p>
                    </div>
                    <div class="practice-info">
                        <p class="center bold">Практическое занятие №5</p>
                        <ol>
                            <li><span class="bold">Наименование</span>: Алгоритм поиска минимального остовного дерева
                            </li>
                            <li><span class="bold">Цель занятия</span>: Научиться практически находить минимальное
                                остовное дерево.
                            </li>
                            <li><span class="bold">Подготовка к занятию</span>:
                                <ol>
                                    <li>Повторить тему: «Алгоритм поиска минимального остовного дерева»</li>
                                    <li>Ответить на вопросы для допуска к занятию:
                                        <ol>
                                            <li>Можно ли в любом связном графе найти подграф, являющийся деревом?</li>
                                            <li>Какой подграф является остовным деревом?</li>
                                            <li>Являются ли графы, показанные на рис.1 и рис.7 остовными деревьями?
                                                Почему?
                                                <div><img src="img/practices/5/1.png"
                                                          alt=""/></div>
                                            </li>
                                            <li>Укажите порядок построения остовного дерева в графе G</li>
                                            <li>Если в графе G имеется n вершин, то сколько ребер необходимо выбрать для
                                                построения остовного дерева?
                                            </li>
                                            <li>Найдите остовные деревья в графе, изображенном на рис. 1.</li>
                                            <li>Для каких целей можно использовать алгоритм поиска минимального
                                                остовного дерева?
                                            </li>
                                        </ol>
                                    </li>
                                </ol>
                            </li>
                            <li><span class="bold">Литература</span>:
                                <ol>
                                    <li>Конспект лекций по учебной дисциплине «Теория алгоритмов»</li>
                                    <li>Приложение к практическому занятию №5</li>
                                </ol>
                            </li>
                            <li><span class="bold">Перечень используемых материалов</span>:
                                <ol>
                                    <li>Канцелярские принадлежности</li>
                                    <li>Бланки для отчета</li>
                                </ol>
                            </li>
                            <li><span class="bold">Задание на занятие:</span>:
                                <ol>
                                    <li>Найдите минимальное остовное дерево графа, изображенного на рис. 2
                                        <div><img src="img/practices/5/2.png"
                                                  alt=""/></div>
                                    </li>
                                    <li>
                                        В таблице приведены расстояния (в милях) между шестью городами Ирландии.
                                        <table class="practice-table" style="width: 100%;">
                                            <tbody>
                                            <tr>
                                                <th></th>
                                                <th>Атлон</th>
                                                <th>Дублин</th>
                                                <th>Голуэй</th>
                                                <th>Лимерик</th>
                                                <th>Слайго</th>
                                                <th>Уэксфорд</th>
                                            </tr>
                                            <tr>
                                                <td>Атлон</td>
                                                <td>-</td>
                                                <td>78</td>
                                                <td>56</td>
                                                <td>73</td>
                                                <td>71</td>
                                                <td>114</td>
                                            </tr>
                                            <tr>
                                                <td>Дублин</td>
                                                <td>78</td>
                                                <td>-</td>
                                                <td>132</td>
                                                <td>121</td>
                                                <td>135</td>
                                                <td>96</td>
                                            </tr>
                                            <tr>
                                                <td>Голуэй</td>
                                                <td>56</td>
                                                <td>132</td>
                                                <td>-</td>
                                                <td>64</td>
                                                <td>85</td>
                                                <td>154</td>
                                            </tr>
                                            <tr>
                                                <td>Лимерик</td>
                                                <td>73</td>
                                                <td>121</td>
                                                <td>64</td>
                                                <td>-</td>
                                                <td>144</td>
                                                <td>116</td>
                                            </tr>
                                            <tr>
                                                <td>Слайго</td>
                                                <td>71</td>
                                                <td>135</td>
                                                <td>85</td>
                                                <td>144</td>
                                                <td>-</td>
                                                <td>185</td>
                                            </tr>
                                            <tr>
                                                <td>Уэксфорд</td>
                                                <td>144</td>
                                                <td>96</td>
                                                <td>154</td>
                                                <td>116</td>
                                                <td>185</td>
                                                <td>-</td>
                                            </tr>
                                            </tbody>
                                        </table>
                                        Используя алгоритм поиска минимального остовного дерева, найдите сеть дорог
                                        минимальной общей длины, связывающую все шесть городов.
                                        <div class="itailc">Вариативная часть</div>
                                    </li>
                                    <li>
                                        <div>Заданы взвешенные графы, изображенные на рис. 3 и 4. Найдите минимальные
                                            остовные деревья, воспользовавшись алгоритмом поиска минимального остовного
                                            дерева.
                                        </div>
                                        <div><img src="img/practices/5/3.png"
                                                  alt=""/></div>
                                    </li>
                                    <li>
                                        <div>Заданы взвешенные графы, изображенные на рис. 5 и 6, найдите минимальные
                                            остовные деревья, воспользовавшись алгоритмом поиска минимального остовного
                                            дерева.
                                        </div>
                                        <div><img src="img/practices/5/4.png"
                                                  alt=""/></div>
                                    </li>
                                </ol>
                            </li>
                            <li><span class="bold">Порядок выполнения работы</span>:
                                <ol>
                                    <li>Получите допуск к работе</li>
                                    <li>Решите задачи 6.1 и 6.2</li>
                                    <li>Сдайте отчет преподавателю и получить зачет</li>
                                    <li>В случае успешной сдачи зачета выполните вариативную часть</li>
                                </ol>
                            </li>
                            <li><span class="bold">Содержание отчета</span>:
                                <div class="italic">Решение задачи 6.1</div>
                                <div class="italic">Решение задачи 6.2</div>
                            </li>
                            <li><span class="bold">Контрольные вопросы</span>:
                                <ol>
                                    <li>В каком виде хранится МОД в памяти компьютера?</li>
                                    <li>Может ли в связном графе существовать несколько остовных деревьев?</li>
                                    <li class="padding">Эквиваленты ли высказывания:
                                        <div>a) Любая пара вершин в G соединена единственным путем</div>
                                        <div>б) G связен и m = n-1</div>
                                        <div>в) G связен, а удаление хотя бы одного его ребра нарушает связанность
                                            графа
                                        </div>
                                        <div>г) G ацикличен, но если добавить хотя бы одно ребро, то в G появится цикл
                                        </div>
                                        Ответ поясните
                                    </li>
                                    <li>Какое ребро при построении МОД выбирается первым?</li>
                                    <li>При построении МОД уже выбраны 2 ребра: е1, е2. Определите Т:=</li>
                                    <li>Что такое Е' в алгоритме построения МОД и как оно определяется?</li>
                                </ol>
                            </li>
                        </ol>
                        <div class="work-done-by">
                            <span>Работу составил преподаватель</span>
                            <span class="right-float">Пронина Т.С.</span>
                        </div>
                    </div>
                    <div class="additional">
                        <p class="center bold">Приложение к практическому занятию №5</p>

                        <div>В любом связном графе найдется подграф, являющийся деревом. Подграф в G, являющийся деревом
                            и включающий в себя все вершины G, называется остовным деревом.
                        </div>
                        <div>Остовное дерево в графе G строится просто: выбираем произвольное его ребро и
                            последовательно добавляем другие ребра, не создавая при этом циклов, до тех пор, пока нельзя
                            будет добавить никакого ребра, не получив при этом цикла. Для построения остовного дерева в
                            графе из n вершин необходимо выбрать ровно n — 1 ребро.
                        </div>
                        <div><span class="bold">Пример 1.</span> Найдите два разных остовных дерева в графе,
                            изображенном на рис.1
                        </div>
                        <div><span class="bold">Решение.</span> В этом графе существует несколько остовных деревьев.
                            Одно из них получается последовательным выбором ребер: а, b, d и f . Другое — b с, е и g.
                            Названные деревья показаны на рис. 7.
                        </div>
                        <div><img src="img/practices/5/5.png"
                                  alt=""/></div>
                        <div>
                            Процесс, описанный в примере 1, можно приспособить для решения задачи <span class="italic">поиска кратчайшего соединения</span>
                            :
                        </div>
                        <div class="italic">Нужно построить железнодорожную сеть, связывающую некоторое число городов.
                            Известна стоимость строительства отрезка путей между любой парой городов. Требуется найти
                            сеть минимальной стоимости.
                        </div>
                        <div>На языке теории графов нам нужно в нагруженном графе найти остовное дерево наименьшего
                            общего веса. Такое дерево принято называть минимальным остовным деревом или, сокращенно,
                            МОД. В отличие от задачи коммивояжера, здесь есть эффективный алгоритм, находящий
                            действительно минимальное остовное дерево. Он похож на алгоритм Прима.
                        </div>
                        <p class="bold">Алгоритм поиска минимального остовного дерева</p>

                        <div>Пусть G = {V, Е) — связный взвешенный граф. Алгоритм строит МОД в графе G, последовательно
                            выбирая ребра наименьшего возможного веса до образования остовного дерева. МОД в памяти
                            компьютера хранится в виде множества Т ребер.
                        </div>
                        <pre>
                            begin
                                е := ребро графа G с наименьшим весом;
                                Т:={е};
                                Е':=Е\{е}
                            while Е' ≠ Ø
                                begin
                                    е' := ребро из Е' наименьшего веса;
                                    Т:=Т  {е'};
                                    Е':= множество ребер из Е' \ {T},
                                    чье добавление к Т не ведет к образованию циклов;
                                end
                            end
                        </pre>
                        <div><span class="bold">Пример 2.</span>В таблице дано расстояние (в милях) между пятью
                            деревнями А, В, С, D и Е. Найдите минимальное остовное дерево.
                        </div>
                        <table class="practice-table" style="width: 100%;">
                            <tbody>
                            <tr>
                                <th></th>
                                <th>A</th>
                                <th>B</th>
                                <th>C</th>
                                <th>D</th>
                                <th>E</th>
                            </tr>
                            <tr>
                                <td>A</td>
                                <td>-</td>
                                <td>13</td>
                                <td>3</td>
                                <td>9</td>
                                <td>9</td>
                            </tr>
                            <tr>
                                <td>B</td>
                                <td>13</td>
                                <td>-</td>
                                <td>11</td>
                                <td>11</td>
                                <td>13</td>
                            </tr>
                            <tr>
                                <td>C</td>
                                <td>3</td>
                                <td>11</td>
                                <td>-</td>
                                <td>9</td>
                                <td>7</td>
                            </tr>
                            <tr>
                                <td>D</td>
                                <td>9</td>
                                <td>11</td>
                                <td>9</td>
                                <td>-</td>
                                <td>2</td>
                            </tr>
                            <tr>
                                <td>E</td>
                                <td>9</td>
                                <td>13</td>
                                <td>7</td>
                                <td>2</td>
                                <td>-</td>
                            </tr>
                            </tbody>
                        </table>
                        <div><span class="bold">Решение</span>Ребра выбираются следующим образом:</div>
                        первое — ребро DE веса 2; <br/>
                        второе — АС веса 3; <br/>
                        третье — СЕ веса 7. <br/>
                        На этой стадии строящееся дерево выглядит так, как на рис. 8 <br/>

                        <div><img src="img/practices/5/6.png"
                                  alt=""/></div>
                        <div>Следующие по весу ребра — AD, АЕ и CD, каждое из которых имеет вес 9. Однако какое бы из
                            них мы ни добавили, получится цикл. Поэтому перечисленные ребра следует исключить из числа
                            доступных для строительства. Далее идут ребра ВС и BD веса 11. Можно присоединить любое из
                            них, получив при этом два разных МОД: [АС, ВС, СЕ, DE] или {АС, BD, СЕ, DE] веса 23 каждое.
                        </div>
                    </div>
                </article>

                <article class="content__item">
                    <span class="category category--full">Практическое занятие №6</span>

                    <h2 class="title title--full">Алгоритм топологической сортировки</h2>

                    <div class="practice-title">
                        <p class="proved right">УТВЕРЖДЕНО</p>

                        <p class="date right">«&nbsp;&nbsp;» ________ 2015 г.</p>

                        <p class="date-sub right">Дата</p>

                        <p class="discipline center">Дисциплина: Теория алгоритмов </p>

                        <h2 class="center">Практическое занятие № 6</h2>

                        <p class="center">Наименование: Алгоритм топологической сортировки</p>

                        <p class="spec indent">по специальности:</p>

                        <p class="spec indent">09.02.03 – Программирование в компьютерных системах</p>

                        <p class="spec indent">Количество часов <u>2</u></p>

                        <p class="new-part indent">РАССМОТРЕНО</p>

                        <p class="indent">на заседании цикловой комиссии <u>Информационные системы и технологии</u></p>

                        <p class="comission indent">наименование П(Ц)К</p>

                        <p class="indent">Председатель ____________<u>/ Шомас Е.А. /</u></p>

                        <p class="sign indent">подпись <span>расшифровка подписи</span></p>

                        <p class="indent">Протокол __________ от «&nbsp;&nbsp;» <u>04</u> 2015 г.</p>

                        <p class="protocol indent">номер <span>дата</span></p>

                        <p class="right">Составил преподаватель</p>

                        <p class="right">Пронина Т.С.</p>

                        <p class="center">Самара, КС ПГУТИ, 2015</p>
                    </div>
                    <div class="practice-info">
                        <p class="center bold">Практическое занятие №6</p>
                        <ol>
                            <li><span class="bold">Наименование</span>: Алгоритм топологической сортировки.</li>
                            <li><span class="bold">Цель занятия</span>: Изучить алгоритм топологической сортировки и его
                                применение к теории графов.
                            </li>
                            <li><span class="bold">Подготовка к занятию</span>:
                                <ol>
                                    <li>Изучить основные понятия об ориентированных графах(орграфах), алгоритм
                                        топологической сортировки и его применение к теории графов.
                                    </li>
                                    <li>Ответить на вопросы для допуска к работе:
                                        <ol>
                                            <li>Что представляет собой орграф?</li>
                                            <li>Чем орграф отличается от неориентированного графа?</li>
                                            <li>Как называются ребра орграфа?</li>
                                            <li>Могут ли в простом орграфе иметься петли и кратные дуги?</li>
                                            <li>Что называется антецедентом? Приведите пример</li>
                                            <li>Что показывает матрица смежности орграфа?</li>
                                            <li>Как построить матрицу смежности орграфа?</li>
                                            <li>Что называется путем в орграфе?</li>
                                            <li>Что называется контуром в орграфе?</li>
                                            <li>Какой орграф называется бесконтурным?</li>
                                            <li>Что на языке теории графов называется системой ПЕРТ?</li>
                                            <li>Для чего используется система ПЕРТ?</li>
                                            <li>Что создает алгоритм топологической сортировки?</li>
                                            <li>В каком случае каждая вершина орграфа в алгоритме топологической
                                                сортировки получает очередную метку?
                                            </li>
                                            <li>Куда записываются антецеденты каждой вершины υ в начале работы алгоритма
                                                топологической сортировки?
                                            </li>
                                            <li>Поясните принцип работы алгоритма топологической сортировки на
                                                примере.
                                            </li>
                                        </ol>
                                    </li>
                                </ol>
                            </li>
                            <li><span class="bold">Литература</span>:
                                <ol>
                                    <li>Хаггарти. Дискретная математика для программистов М.: Техносфера, 2012. –
                                        320с.
                                    </li>
                                    <li>Конспект лекций по учебной дисциплине «Теория алгоритмов»</li>
                                    <li>Приложение к практическому занятию №6</li>
                                </ol>
                            </li>
                            <li><span class="bold">Перечень используемых материалов</span>:
                                <ol>
                                    <li>Канцелярские принадлежности</li>
                                    <li>Бланк для отчета</li>
                                </ol>
                            </li>
                            <li><span class="bold">Задание на занятие:</span>:
                                <ol>
                                    <li>Примените алгоритм топологической сортировки к орграфу со следующей матрицей
                                        смежности:
                                        <div><img src="img/practices/6/1.png"
                                                  alt=""/></div>
                                    </li>
                                    <li>
                                        Напишите новую матрицу смежности, строки и столбцы которой упорядочены в
                                        соответствии с новыми обозначениями вершин. Что можно сказать о новой матрице?
                                        <div class="italic">Вариативная часть:</div>
                                    </li>
                                    <li>
                                        <div>Вопрос для письменного ответа.</div>
                                        Что можно ожидать от алгоритма топологической сортировки в случае орграфа из
                                        примера 1, приведенного в Приложении А.
                                    </li>
                                    <li>
                                        В таблице 1 приведен список действий по приготовлению цыпленка с расставленными
                                        приоритетами. Упорядочите список согласно приоритетам.
                                        <table class="practice-table" style="width: 100%;">
                                            <tbody>
                                            <tr>
                                                <th>Задания</th>
                                                <th></th>
                                                <th>Предварительные действия</th>
                                            </tr>
                                            <tr>
                                                <td>А</td>
                                                <td>Добавить лук к цыпленку</td>
                                                <td>И</td>
                                            </tr>
                                            <tr>
                                                <td>Б</td>
                                                <td>Вымыть салат-латук</td>
                                                <td>Л</td>
                                            </tr>
                                            <tr>
                                                <td>В</td>
                                                <td>Приготовить салатную заправку</td>
                                                <td>Л</td>
                                            </tr>
                                            <tr>
                                                <td>Г</td>
                                                <td>Перемешать жаркое</td>
                                                <td>К</td>
                                            </tr>
                                            <tr>
                                                <td>Д</td>
                                                <td>Перемешать салат</td>
                                                <td>Б, В</td>
                                            </tr>
                                            <tr>
                                                <td>Е</td>
                                                <td>Разрезать цыпленка</td>
                                                <td>Никаких</td>
                                            </tr>
                                            <tr>
                                                <td>Ж</td>
                                                <td>Растереть имбирь</td>
                                                <td>И</td>
                                            </tr>
                                            <tr>
                                                <td>З</td>
                                                <td>Подать готовое блюдо</td>
                                                <td>И</td>
                                            </tr>
                                            <tr>
                                                <td>И</td>
                                                <td>Замариновать цыпленка</td>
                                                <td>Е</td>
                                            </tr>
                                            <tr>
                                                <td>К</td>
                                                <td>Поставить казанок на огонь</td>
                                                <td>А, Ж, З, Л</td>
                                            </tr>
                                            <tr>
                                                <td>Л</td>
                                                <td>Приготовить рис</td>
                                                <td>Никаких</td>
                                            </tr>
                                            </tbody>
                                        </table>
                                    </li>
                                </ol>

                            </li>
                            <li><span class="bold">Порядок выполнения работы</span>:
                                <ol>
                                    <li>Получите допуск к работе</li>
                                    <li>Решите задачу п.6.1 и представьте граф, соответствующий заданной матрице
                                        смежности.
                                    </li>
                                    <li>Письменно ответьте на вопрос 6.2.</li>
                                    <li>Сдайте отчет преподавателю, получите зачет. В случае успешного получения зачета
                                        выполните вариативную часть.
                                    </li>
                                </ol>
                            </li>
                            <li><span class="bold">Содержание отчета</span>:
                                <div class="italic">Решение задачи 6.1, а также ответ на вопрос п.6.2.</div>
                            </li>
                            <li><span class="bold">Контрольные вопросы</span>:
                                <ol>
                                    <li>Является ли матрица смежности орграфа, полученного в результате решения задачи 1
                                        симметричной? Почему?
                                    </li>
                                    <li>В каком случае матрица смежности (см. 9.1) была бы симметричной?</li>
                                    <li> Возможно ли это (см. 9.2) в случае простого орграфа, неориентированного
                                        графа?
                                    </li>
                                </ol>
                            </li>
                        </ol>
                        <div class="work-done-by">
                            <span>Работу составил преподаватель</span>
                            <span class="right-float">Пронина Т.С.</span>
                        </div>
                    </div>
                    <div class="additional">
                        <p class="center bold">Приложение к практическому занятию №6</p>

                        <p class="center bold">Ориентированные графы и система ПЕРТ</p>

                        <div> Ориентированные графы или, для краткости, орграфы используются для моделирования ситуаций,
                            в которых есть отношение частичного порядка между объектами. Возникающие при этом схемы
                            служат для изображения схем информационных потоков, сетевого планирования и планирования
                            заданий. ПЕРТ – это система планирования и руководства разработками. На английском языке ее
                            называют PERT – сокращение от «Program Evaluation and Rewiew Technique». ПЕРТ была
                            разработана для помощи в конструировании подводной лодки военно-морского флота США.
                        </div>
                        <div>Система ПЕРТ может использоваться при проектировании корпоративных информационных систем.
                            Ориентированный граф или орграф представляет собой пару G = (V, E), где V – конечное
                            множество вершин, а Е – отношение на V или количество ребер. Графическое изображение графа
                            состоит из множества помеченных вершин с ориентированными ребрами (называемых дугами),
                            соединяющими пары вершин. Совокупность всех дуг образует множество Е.
                        </div>
                        <div>Дугу, соединяющую пару (u, υ) вершин u и υ орграфа G, будем обозначать через uυ. В простом
                            орграфе отсутствуют петли и кратные дуги. Следовательно, для любой пары вершин u и υ в
                            орграфе найдется не более одной дуги uυ из вершины u в υ, и не более одной дуги υu из υ в u.
                            Если uυ – дуга орграфа, то u называют антецедентом υ.
                        </div>
                        <div>На рис. 1. приведен пример простого орграфа с множеством вершин
                            V = {a, b, c, d} и множеством дуг Е = {ab, bd, cb, bd, cd}.
                        </div>
                        <div><img src="img/practices/6/2.png"
                                  alt=""/></div>
                        Матрицей смежности данного графа служит матрица
                        <div><img src="img/practices/6/3.png"
                                  alt=""/></div>
                        (вершины a, c, и d здесь – антецеденты b).
                        <div>Путем длины k в орграфе называют последовательность различных вершин υ0 , υ1, …, υk ,
                            каждая пара υi – 1 υi которой образует дугу (i = 1, …, k).
                        </div>
                        <div>Контуром в орграфе G принято называть последовательность
                            вершин υ0 , υ1, …, υk , образующую путь, в которой первая вершина υ0 совпадает с последней
                            υk , а других повторяющихся вершин в ней нет. Орграф G называют бесконтурным, если в нем нет
                            контуров.
                        </div>
                        <div>Бесконтурные орграфы полезны в качестве моделей ситуаций, задачи в которых должны
                            выполняться в определенном порядке. В задаче о планировании заданий соответствующий
                            бесконтурный орграф имеет кодовое название «система ПЕРТ».
                        </div>
                        <div><span class="bold">Пример 1.</span> Для получения степени магистра биологии студенту
                            университета, в частности, необходимо прослушать восемь курсов, которые некоторым образом
                            зависят друг от друга. Эта зависимость представлена в табл.1. Изобразите систему ПЕРТ,
                            иллюстрирующую приоритетную структуру курсов.
                        </div>
                        Таблица 1
                        <table class="practice-table" style="width: 100%;">
                            <tbody>
                            <tr>
                                <th></th>
                                <th></th>
                                <th>Предварительные курсы</th>
                            </tr>
                            <tr>
                                <td>(A)</td>
                                <td>Биотехнология</td>
                                <td>B</td>
                            </tr>
                            <tr>
                                <td>(B)</td>
                                <td>Начальный курс биотехнологии</td>
                                <td>C</td>
                            </tr>
                            <tr>
                                <td>(C)</td>
                                <td>Цитология</td>
                                <td>H</td>
                            </tr>
                            <tr>
                                <td>(D)</td>
                                <td>Структура ДНК</td>
                                <td>C</td>
                            </tr>
                            <tr>
                                <td>(E)</td>
                                <td>Энзимология</td>
                                <td>D, G</td>
                            </tr>
                            <tr>
                                <td>(F)</td>
                                <td>Диетология</td>
                                <td>E</td>
                            </tr>
                            <tr>
                                <td>(G)</td>
                                <td>Генная инженерия</td>
                                <td>C</td>
                            </tr>
                            <tr>
                                <td>(H)</td>
                                <td>Биология человека</td>
                                <td>Никаких требований</td>
                            </tr>
                            </tbody>
                        </table>
                        <div><span class="bold">Решение.</span> Система ПЕРТ (см. рис.2) – это просто орграф,
                            представляющий данную приоритетную структуру. Вершины орграфа в данном случае – восемь
                            курсов. Для краткости ссылок мы обозначим курсы буквами латинского алфавита от А до Н. Дуги
                            орграфа отражают представленные в таблице требования, необходимые для усвоения данного
                            курса.
                        </div>
                        <div><img src="img/practices/6/4.png"
                                  alt=""/></div>
                        <div>Предположим, что студент из примера 1 намерен определить порядок, в котором ему следует
                            изучать предметы, учитывая их зависимость друг от друга. Он может сделать это с помощью
                            алгоритма топологической сортировки. Алгоритм создает последовательность согласованных меток
                            для вершин бесконтурного орграфа таким образом, что если 1, 2, 3, …, n – метки вершин и uυ –
                            дуга орграфа, идущая от вершины u с меткой i к вершине υ с меткой j, то i < j.
                        </div>
                        <div><span class="bold">Алгоритм топологической сортировки.</span> Алгоритм генерирует
                            последовательность согласованных меток для вершин бесконтурного орграфа G = (V, E).
                        </div>
                        <div>В самом начале работы алгоритма антецеденты каждой вершины υ записываются в множество
                            А(υ).
                        </div>
                        <pre>
                            begin
                                for υ ∈ V do
                                  вычислить A(υ);
                                  label:= 0;
                                  while остаются неотмеченные вершины, для которых
                                             A(υ) = ∅ do
                                           begin
                                                  label:=1;
                                                     u:= вершина с А(u) = ∅;
                                                  присвоить метку вершине u;
                                                  for каждой неотмеченной вершины υ ∈ V do;
                                                  А(υ):= A(υ) \ {u};
                                            end
                            end
                        </pre>
                        <div>Алгоритм успешно присваивает метки вершинам. Каждая вершина получает очередную метку в том
                            случае, если у нее нет неотмеченных антецедентов.
                        </div>
                        <div><span class="bold">Пример 2.</span> Найдите последовательность меток для орграфа,
                            изображенного на рис.2.
                        </div>
                        <div class="bold">Решение</div>
                        <div><span class="bold">Шаг 0 </span>Множество антецедентов выглядит следующим образом:</div>
                        <div><img src="img/practices/6/5.png"
                                  alt=""/></div>
                        <div><span class="bold">Шаг 1 </span>Первый проход цикла while. Назначить метку 1 вершине Н и
                            удалить вершину Н из всех оставшихся множеств А(υ).
                        </div>
                        <div><img src="img/practices/6/6.png"
                                  alt=""/></div>
                        <div><span class="bold">Шаг 2 </span>Второй проход цикла while. Назначить метку 2 вершине C и
                            удалить вершину C из всех оставшихся множеств А(υ).
                        </div>
                        <div><img src="img/practices/6/7.png"
                                  alt=""/></div>
                        <div><span class="bold">Шаг 3 </span>Третий проход цикла while. Теперь у нас появился выбор:
                            какой вершине присвоить очередную метку? В зависимости от нашего выбора, получатся разные
                            последовательности меток. Присвоим , например , метку 3 вершине В и удалим В из множеств
                            А(υ). A(A) = ∅, A(D) = ∅, A(E) = {D, G}, A(F) = {E}, A(G) = ∅.
                        </div>
                        <div><span class="bold">Шаг 4 </span>Четвертый проход цикла while. Мы снова стоим перед выбором.
                            Назначим метку 4 вершине А и удалим вершину А из А(υ). A(D) = ∅, A(E) = {D,G}, A(F) = {E},
                            A(G) = ∅.
                        </div>
                        <div><span class="bold">Шаг 5 </span>Пятый проход цикла while. Назначим метку 5 вершине D и
                            удалим вершину D из А(υ). A(E) = {G}, A(F) = {E}, A(G) = ∅.
                        </div>
                        <div><span class="bold">Шаг 6 </span>Шестой проход цикла while. Назначим метку 6 вершине G и
                            удалим вершину G из А(υ). A(E) = ∅, A(F) = ∅.
                        </div>
                        <div><span class="bold">Шаг 7 </span>Седьмой проход цикла while. Назначаем метку 7 вершине Е и
                            удаляем Е из списка А(υ). Останется только A(F) = ∅.
                        </div>
                        <div><span class="bold">Шаг 8 </span>Последний проход цикла while. Назначаем метку 8 вершине F.
                            Итак, один из возможных приоритетных списков: H, C, B, A, D, G, E, F. Он дает нам порядок, в
                            котором можно изучать курсы, соблюдая должную последовательность.
                        </div>


                    </div>
                </article>

                <article class="content__item">
                    <span class="category category--full">Практическое занятие №7</span>

                    <h2 class="title title--full">Алгоритм Прима</h2>

                    <div class="practice-title">
                        <p class="proved right">УТВЕРЖДЕНО</p>

                        <p class="date right">«&nbsp;&nbsp;» ________ 2015 г.</p>

                        <p class="date-sub right">Дата</p>

                        <p class="discipline center">Дисциплина: Теория алгоритмов </p>

                        <h2 class="center">Практическое занятие № 7</h2>

                        <p class="center">Наименование: Алгоритм Прима</p>

                        <p class="spec indent">по специальности:</p>

                        <p class="spec indent">09.02.03 – Программирование в компьютерных системах</p>

                        <p class="spec indent">Количество часов <u>2</u></p>

                        <p class="right">Составил преподаватель</p>

                        <p class="right">Пронина Т.С.</p>

                        <p class="center">Самара, КС ПГУТИ, 2015</p>
                    </div>
                    <div class="practice-info">
                        <p class="center bold">Практическое занятие №7</p>
                        <ol>
                            <li><span class="bold">Наименование</span>: Алгоритм Прима</li>
                            <li><span class="bold">Цель занятия</span>: Научиться с помощью алгоритма Прима находить
                                сеть минимальной длины, связывающую все заданные пункты.
                            </li>
                            <li><span class="bold">Подготовка к занятию</span>:
                                <ol>
                                    <li>Повторить тему: “Алгоритм Прима”</li>
                                    <li>Ответить на контрольные вопросы
                                        <ol>
                                            <li>Какая вершина выбирается первой в алгоритме Прима?</li>
                                            <li>Какое ребро выбирается первым в алгоритме Прима?</li>
                                            <li>Что может являться весом ребра?</li>
                                            <li>Какая вершина выбивается второй?</li>
                                            <li>Что необходима сделать после выбора второй вершины?</li>
                                            <li>Как будет выбираться третья вершина?</li>
                                            <li>Сколько шагов содержит алгоритм Прима?</li>
                                            <li>Укажите недостатки словесного алгоритма.</li>
                                            <li>Какой граф называется связным?</li>
                                            <li>Укажите первую форму оператора цикла (for…)</li>
                                            <li>Укажите вторую форму оператора цикла (while…)</li>
                                        </ol>
                                    </li>
                                </ol>
                            </li>
                            <li><span class="bold">Литература</span>:
                                <ol>
                                    <li>Р. Хаггарти. Дискретная математика для программистов М. Техносфера. 2012 – 320
                                        с.
                                    </li>
                                    <li>Конспект лекций по учебной дисциплине «Теория алгоритмов»</li>
                                    <li>Приложение к практическому занятию №7</li>
                                </ol>
                            </li>
                            <li><span class="bold">Перечень используемых материалов</span>:
                                <ol>
                                    <li>Канцелярские принадлежности</li>
                                    <li>Бланк для отчета</li>
                                </ol>
                            </li>
                            <li><span class="bold">Задание на занятие:</span>:
                                <ol>
                                    <li>6.1 Граф на рисунке рис. 1 изображает сеть дорог, связываю¬щих семь деревень.
                                        Расстояние между деревнями задано в милях. Используя алгоритм Прима, найдите
                                        сеть дорог ми¬нимальной общей длины, охватывающую все деревни, используя
                                        алгоритм Прима.
                                        <div><img src="img/practices/7/1.png"
                                                  alt=""/></div>
                                    </li>
                                    <li>Проследите работу алгоритма на примере сети дорог, из задачи 6.1. Какой
                                        получится результат?

                                    <pre>
                                        begin
                                                 Упорядочите ребра графа по убыванию веса
                                                 и пронумеруйте их числами: 1,2,3, …и т.д.;
                                                 m := число вершин;
                                                 остаток := число рёбер;
                                                 текущее := 1
                                                  while остаток > m-1 do
                                                   begin
                                                           if удаление ребра с номером “текущее”
                                                           не нарушает связности графа then
                                                    begin
                                                             удалить ребро “текущее”;
                                                             остаток := остаток - 1;
                                                         end
                                                           текущее := текущее + 1;
                                                     end
                                        end
                                    </pre>
                                    </li>
                                    <li>Заданы взвешенные графы, изображенные на рис.2 и 3, найдите минимальные остовные
                                        деревья, воспользовавшись алгоритмом Прима
                                        <div><img src="img/practices/7/2.png"
                                                  alt=""/></div>
                                        <div class="italic">Вариативная часть</div>
                                    </li>
                                    <li>
                                        Заданы взвешенные графы, изображенные на рис. 4 и 5, найдите минимальные
                                        оставные деревья, воспльзовавшись алгоритмом Прима с матрицами.
                                        <div><img src="img/practices/7/3.png"
                                                  alt=""/></div>
                                    </li>
                                </ol>
                            </li>
                            <li><span class="bold">Порядок выполнения работы</span>:
                                <ol>
                                    <li>Получите допуск к работе</li>
                                    <li>Выполните задания п.п 61 и 6.2</li>
                                    <li>Оформите отчёт, сдайте его преподавателю, получите зачёт</li>
                                    <li>В случае успешной сдачи зачёта выполните вариативную часть</li>
                                </ol>
                            </li>
                            <li><span class="bold">Содержание отчета</span>:
                                <div class="italic">Решение задачи п. 6.1 ( с выбором первоначальных вершин B и C)</div>
                                <div class="italic">Решение задачи п. 6.2</div>
                            </li>
                            <li><span class="bold">Контрольные вопросы</span>:
                                <ol>
                                    <li>Сравните решения задачи 6.1 с выбором в качестве первоначальных вершин B и C
                                    </li>
                                    <li>Какую роль при размещении компьютерной сети играет алгоритм Прима?</li>
                                    <li>В каких отраслях (подотраслях) народного хозяйства может использоваться алгоритм
                                        Прима? Для чего?
                                    </li>
                                </ol>
                            </li>
                        </ol>
                        <div class="work-done-by">
                            <span>Работу составил преподаватель</span>
                            <span class="right-float">Пронина Т.С.</span>
                        </div>
                    </div>
                    <div class="additional">
                        <p class="center bold">Приложение к практическому занятию №7</p>

                        <div class="italic">Расстояние (в милях) между шестью шотландскими горо¬дами: Абердин, Эдинбург,
                            Форт Уильям, Глазго, Инвернесс и Пёрт дано в таблице 1. Дорожную сеть минимальной длины,
                            связывающую все шесть городов.
                        </div>
                        <table class="practice-table" style="width: 100%;">
                            <tbody>
                            <tr>
                                <th></th>
                                <th>Абердин</th>
                                <th>Эдинбург</th>
                                <th>Форт Уильям</th>
                                <th>Глазго</th>
                                <th>Инвернесс</th>
                                <th>Перт</th>
                            </tr>
                            <tr>
                                <td>Абердин</td>
                                <td>-</td>
                                <td>120</td>
                                <td>147</td>
                                <td>142</td>
                                <td>107</td>
                                <td>81</td>
                            </tr>
                            <tr>
                                <td>Эдинбург</td>
                                <td>120</td>
                                <td>-</td>
                                <td>132</td>
                                <td>42</td>
                                <td>157</td>
                                <td>45</td>
                            </tr>
                            <tr>
                                <td>Форт Уильям</td>
                                <td>147</td>
                                <td>132</td>
                                <td>-</td>
                                <td>108</td>
                                <td>66</td>
                                <td>105</td>
                            </tr>
                            <tr>
                                <td>Глазго</td>
                                <td>142</td>
                                <td>42</td>
                                <td>108</td>
                                <td>-</td>
                                <td>168</td>
                                <td>61</td>
                            </tr>
                            <tr>
                                <td>Инвернесс</td>
                                <td>107</td>
                                <td>157</td>
                                <td>66</td>
                                <td>168</td>
                                <td>-</td>
                                <td>112</td>
                            </tr>
                            <tr>
                                <td>Перт</td>
                                <td>81</td>
                                <td>45</td>
                                <td>105</td>
                                <td>61</td>
                                <td>112</td>
                                <td>-</td>
                            </tr>
                            </tbody>
                        </table>
                        <div>Мы нарисуем граф, чьи вершины обозначают города, а рёбра-дороги их связывающие. Каждое
                            ребро нашего графа, изображенного на рис. 6, снабжено весом, который означает расстояние
                            между соответствующими городами согласно табл.1.
                        </div>
                        <div> Для решение поставленной задачи с помощью алгоритма Прима, мы построим новый граф, имеющий
                            минимальный общий вес, в котором все шесть городов будут соединены дорогами.
                        </div>
                        <div class="bold center">Алгоритм Прима</div>
                        <div><span class="bold">Шаг 1</span>Выберите произвольную вершину и ребро, соединяющее её с
                            ближайшим (по весу) соседом.
                        </div>
                        <div><span class="bold">Шаг 2</span>Найдите не присоединённую (ещё) вершину, ближе всего лежащую
                            к из одной присоединённых, и соедините с ней.
                        </div>
                        <div><span class="bold">Шаг 3</span>Повторяйте шаг 2 до тех пор, пока все вершины не будут
                            присоединены.
                        </div>
                        <div>На рисунках 6.1, 6.2, 6.3 изображена последовательность графов, которая получается в
                            результате применения алгоритма Прима, ес¬ли начинать с вершины Перт. Последний граф (с
                            общим весом 339) представляет собой минимальную сеть дорог, охватывающую все шесть городов.
                        </div>
                        <img src="img/practices/7/4.png"
                             alt=""/>
                        <img src="img/practices/7/5.png"
                             alt=""/>
                        <img src="img/practices/7/6.png"
                             alt=""/>
                        <img src="img/practices/7/7.png"
                             alt=""/>

                        <div>Алгоритм, который мы применяли, написан на обычном русском языке. Разговорный язык может
                            оказаться слишком многоречивым, неоднозначным и, в следствие этого, не соответствующим
                            запутанной проблеме. Мы могли бы написать программу для компьютера, реализующую алгоритм, но
                            какой язык выбрать? Кроме того, язык программирования зачастую скрывает истинный смысл
                            алгоритма от неопытного читателя! Подходящий компромисс в этой ситуации — использовать так
                            называемый псевдокоду, состоящий из небольшого числа структурных языковых элементов вместе с
                            русско- подобным описанием действий реализуемого алгоритма (см. п. 6.2).
                        </div>
                    </div>
                </article>

                <article class="content__item">
                    <span class="category category--full">Практическое занятие №8</span>

                    <h2 class="title title--full">Алгоритм Дейстры</h2>

                    <div class="practice-title">
                        <p class="proved right">УТВЕРЖДЕНО</p>

                        <p class="date right">«&nbsp;&nbsp;» ________ 2015 г.</p>

                        <p class="date-sub right">Дата</p>

                        <p class="discipline center">Дисциплина: Теория алгоритмов </p>

                        <h2 class="center">Практическое занятие № 8</h2>

                        <p class="center">Наименование: Алгоритм Дейстры</p>

                        <p class="spec indent">по специальности:</p>

                        <p class="spec indent">09.02.03 – Программирование в компьютерных системах</p>

                        <p class="spec indent">Количество часов <u>2</u></p>

                        <p class="right">Составил преподаватель</p>

                        <p class="right">Пронина Т.С.</p>

                        <p class="center">Самара, КС ПГУТИ, 2015</p>
                    </div>
                    <div class="practice-info">
                        <p class="center bold">Практическое занятие №8</p>
                        <ol>
                            <li><span class="bold">Наименование</span>: Алгоритм Дейкстры</li>
                            <li><span class="bold">Цель занятия</span>: Научиться практически применять алгоритм
                                Дейкстры для поиска кратчайшего пути, связывающего вершины в нагруженном графе.
                            </li>
                            <li><span class="bold">Подготовка к занятию</span>:
                                <ol>
                                    <li>Повторить тему «Алгоритм Дейкстры»</li>
                                    <li>Ответить на вопросы для допуска к занятию
                                        <ol>
                                            <li>Что называется ориентированным графом(орграфом)?</li>
                                            <li>Что называется дугами орграфа?</li>
                                            <li>Что называется путем длины k в орграфе?</li>
                                            <li>Что называется нагруженным графом?</li>
                                            <li>Какой путь называется кратчайшим?</li>
                                            <li>Можно ли методом перебора найти наиболее короткий путь, соединяющий
                                                соответствующие пункты?
                                            </li>
                                            <li>Для чего используется алгоритм Дейкстры?</li>
                                            <li>Что называется расстоянием от вершины v до вершины u?</li>
                                            <li>Какой формулой определяются элементы весовой матрицы алгоритма Дейкстры,
                                                если
                                                а) U = V <br/>
                                                б) U и V не соединены дугой <br/>
                                                в) если U×V -дуга веса d <br/>
                                            </li>
                                            <li>В каком случае элемент матрицы wij=∞?</li>
                                            <li>Изменяется ли расстояние d[V] в процессе работы с алгоритмом Дейкстры?
                                            </li>
                                            <li>Какая вершина выбирается первой при работе с алгоритмом Дейкстры?</li>
                                        </ol>
                                    </li>
                                </ol>
                            </li>
                            <li><span class="bold">Литература</span>:
                                <ol>
                                    <li>Р.Хаггарти. Дискретная математика для программистов
                                        М. Техносфера. 2012 – 320 с.
                                    </li>
                                    <li>Конспект лекций по учебной дисциплине «Теория алгоритмов»</li>
                                    <li>Приложение к практическому занятию №2</li>
                                </ol>
                            </li>
                            <li><span class="bold">Перечень используемых материалов</span>:
                                <ol>
                                    <li>Канцелярские принадлежности</li>
                                    <li>Бланк для отчета</li>
                                </ol>
                            </li>
                            <li><span class="bold">Задание на занятие:</span>:
                                <ol>
                                    <li>
                                        <div>Проследите за работой алгоритма Дейкстры на примере орграфа, изображенного
                                            на рис.1,и найдите кратчайшие пути до каждой вершины:
                                        </div>
                                        а) от вершины А; <br/>
                                        б) от вершины С. <br/>

                                        <div><img src="img/practices/8/1.png"
                                                  alt=""/></div>
                                        <div class="italic">Вариантивная часть:</div>
                                    </li>
                                    <li>
                                        <div>С помощью алгоритма Дейкстры найдите кратчайший путь от вершины S до всех
                                            остальных вершин в нагруженном графе из рис.2.Найдите два кратчайших пути от
                                            S до T.
                                        </div>
                                        <div><img src="img/practices/8/2.png"
                                                  alt=""/></div>
                                    </li>
                                </ol>
                            </li>
                            <li><span class="bold">Порядок выполнения работы</span>:
                                <ol>
                                    <li>Получите допуск к работе</li>
                                    <li>Выполните задание п. 6.1</li>
                                    <li>Оформите отчет, сдайте преподавателю, получите зачет</li>
                                    <li>В случае успешной сдачи зачёта выполните вариативную часть</li>
                                </ol>
                            </li>
                            <li><span class="bold">Содержание отчета</span>:
                                Решение задач п. 6.1
                            </li>
                            <li><span class="bold">Контрольные вопросы</span>:
                                <ol>
                                    <li>Как отмечается (выбирается) расстояние в первой строке таблицы?</li>
                                    <li>Как выбирается вторая вершина? Последующие вершины?</li>
                                    <li>Какие значения понимают d (v), если новые значения оказываются меньше старых?
                                    </li>
                                    <li>Какие вершины перечисляются в список PATHTO (v), если за исходную принята
                                        вершина А?
                                    </li>
                                </ol>
                            </li>
                        </ol>
                        <div class="work-done-by">
                            <span>Работу составил преподаватель</span>
                            <span class="right-float">Пронина Т.С.</span>
                        </div>
                    </div>
                    <div class="additional">
                        <p class="center bold">Приложение к практическому занятию №8</p>

                        <div>Ориентированные графы или, для краткости, орграфы используются для моделирования ситуаций,
                            в которых есть отношение частичного порядка между объектами. Возникающие при этом схемы
                            служат для изображения схем информационных потоков, сетевого планирования и планирования
                            заданий.
                        </div>
                        <div>Ориентированный граф или орграф представляет собой пару G=(V,E), где V-конечное множество
                            вершин, а Е-отношение на V. Графическое изображение графа состоит из множества помеченных
                            вершин с ориентированными ребрами (дугами), соединяющими пары вершин. Совокупность всех дуг
                            образует множество Е.
                        </div>
                        <div>На рисунке приведен пример простого орграфа с множеством вершин V={a,b,c,d} и множеством
                            дуг E={ab,bd,cb,db,dc}.
                        </div>
                        <div><img src="img/practices/8/3.png"
                                  alt=""/></div>
                        <div>Рассмотрим задачу поиска кратчайшего пути, связывающего пару
                            данных вершин в нагруженном орграфе. Слово «кратчайший» здесь вполне уместно, поскольку
                            довольно часто веса в орграфе — это расстояния между пунктами.
                        </div>
                        <div>Типичная ситуация, которая моделируется нагруженным орграфом, это транспортная сеть (по
                            которой товары доставляются из города в город) и коммуникационная сеть (по которой
                            переправляется информация).
                        </div>
                        <div>Рассмотрим нагруженный граф на рис. 3. Он может представлять, например, длины дорог в
                            километрах между шестью деревнями. Поскольку количество вершин в этом графе невелико, то
                            перебрать все возможные пути между любой парой заданных вершин нам вполне по силам. При
                            этом, естественно, мы найдем наиболее короткий путь, соединявший соответствующие деревни. В
                            реальной задаче, возникающей в профессиональной деятельности, число вершин, как правило,
                            настолько велико, что такой упрощенный подход к поиску кратчайшего пути слишком
                            неэффективен.
                        </div>
                        <div><img src="img/practices/8/4.png"
                                  alt=""/></div>
                        Именно алгоритм Дейстры, играет центральную роль при создании динамических таблиц маршрутов в
                        коммуникационных сетях.
                        <div>Допустим, что нужно найти кратчайший путь от вершины А к любой другой вершине орграфа (см.
                            рис. 4). Кратчайший путь — это путь минимального общего веса, соединяющий выбранные вершины.
                            Общий вес, по определению, равен сумме весов всех дуг, составлявших путь. Общий вес
                            кратчайшего пути, ведущего из вершины u в вер¬шину v, называют расстоянием от u до v.
                            Определим весовую матрицу W, чьи элементы w{u, v) задаются формулой
                        </div>
                        <div><img src="img/practices/8/5.png"
                                  alt=""/></div>
                        Для нашего графа весовая матрица выглядит следующим образом:
                        <div><img src="img/practices/8/6.png"
                                  alt=""/></div>

                        <div>В течение работы алгоритма каждой вершине v орграфа при¬сваивается число d[v], равное
                            расстоянию от вершины a до v. Перед началом работы d[v] совпадает с весом дуги (A, v), если
                            такая существует, или равно ∞ в противном случае. Мы будем проходить вершины орграфа и
                            уточнять значения d[v].
                        </div>
                        <div>На каждом шаге алгоритма отмечается одна вершина u, до ко¬торой уже найден кратчайший путь
                            от А и расстояние d[u] до нее. Далее полученное значение d[u] отмеченной вершины не
                            меняется. Для оставшихся, неотмеченных вершин v, число d[v] будет меняется с учетом того,
                            что искомый кратчайший путь до них от А будет проходить через последнюю отмеченную вершину
                            u. Алгоритм за¬вершится в тот момент, когда все возможные вершины будут отме¬чены и получат
                            свои окончательные значения d[v].
                        </div>
                        <div>Для каждого шага алгоритма, описанного ниже, в соответствующую строку табл. 1 заносится
                            отмеченная вершина, текущие зна¬чения d[v] и оставшиеся неотмеченные вершины. При этом
                            полу¬жирным шрифтом выделяется наименьшее из значений d[v] среди неотмеченных вершин.
                            Соответствующую вершину следует отме¬тить. Кроме того, в таблице все значения d[v] для уже
                            отмеченных вершин отделены от остальных ломаной линией.
                        </div>

                        <div><img src="img/practices/8/7.png"
                                  alt=""/></div>
                        <div class="bold">Шаг 0</div>
                        <div>Поскольку мы интересуемся кратчайшими путями от вер¬шины А, мы ее отмечаем и используем
                            первую строку весовой матрицы W для определения начальных значений d[v]. Таким образом
                            получается первая строка таблицы. Наи¬меньшее число из всех d[v] для неотмеченных вершин —
                            это d[B] = 2.
                        </div>
                        <div class="bold">Шаг 1</div>
                        <div>Отмечаем вершину B, так как она является ближайшей к А. Вычисляем длины путей, ведущих от А
                            к неотмеченным вершинам через вершину В. Если новые значения d[v] ока¬зываются меньше
                            старых, то меняем последние на новые. Итак, при этом проходе цикла путь ABC имеет вес 3, а
                            путь ABE — 6, в то время как старые расстояния до этих вершин от А были ∞. Следовательно,
                            заполняя вто¬рую строку таблицы, мы заменим d[C] на 3 и d[E] на 6.
                        </div>
                        <div class="bold">Шаг 2</div>
                        <div>Из оставшихся неотмеченными, вершины С и D находятся ближе всех к А. Отметить можно любую
                            из них. Возьмем вершину D. Так как длина пути ADE равна 5, текущее значение d[E] следует
                            уменьшить до 5. Теперь можно за-полнить третью строчку таблицы. Наименьшее значение d[v]
                            среди неотмеченных к этому моменту вершин оказы¬вается у вершины С.
                        </div>

                        <div class="bold">Шаг 3</div>
                        <div>Отмечаем вершину С и подправляем значения d[v]. Теперь можно дойти и до вершины F, следуя
                            путем АВCF. Его длина, а стало быть и значение d[F], равны 8. К этому моменту остались
                            неотмеченными две вершины: Е и F.
                        </div>
                        <div class="bold">Шаг 4</div>
                        <div>Мы отмечаем вершину E, что позволяет нам уменьшить величину d[F] с 8 до 6.</div>
                        <div class="bold">Шаг 5</div>
                        <div>Отмечаем вершину F.</div>

                        <p class="bold">Алгоритм Дейкстры</p>

                        <div>Пусть (V, Е) — нагруженный граф, и А — его вершина. Алго¬ритм выбирает кратчайший путь от
                            вершины А до любой вершины v и присваивает его длину переменной d[v]. Для вершин u и v через
                            w(u,v) мы обозначаем вес дуги uv, а в списке РАТНТО(v) перечи¬сляются вершины кратчайшего
                            пути от А до v.
                        </div>
                        <pre>
                    begin
                           for каждой  v ϵ ν do
                                 begin
                                         d[v]   □(∶=) w (A, v);
                                         PATHTO (v) ∶= A;
                                 end

                        Отметить вершину A;
                        while остаются неотмеченные вершины do
                                  begin
                                        u □(∶=) неотмеченную вершину с минимальным
                                                расстоянием от A;
                                        Отметить вершину u;
                                          for каждой неотмеченной вершины v
                                                с условием uv Є E do
                                              begin
                                              d' □(∶=)  d[u] + w (u,v)
                                                     if d' < d[u] then
                                                          begin
                                                             d[u]  □(∶=) d '
                                                             PATHTO (v) ∶= PATHTO (u), v;
                                                          end
                                               end
                    end
                        </pre>
                    </div>
                </article>

                <article class="content__item">
                    <span class="category category--full">Практическое занятие №9</span>

                    <h2 class="title title--full">Эффективность алгоритмов</h2>

                    <div class="practice-title">
                        <p class="proved right">УТВЕРЖДЕНО</p>

                        <p class="date right">«&nbsp;&nbsp;» ________ 2015 г.</p>

                        <p class="date-sub right">Дата</p>

                        <p class="discipline center">Дисциплина: Теория алгоритмов </p>

                        <h2 class="center">Практическое занятие № 9</h2>

                        <p class="center">Наименование: Эффективность алгоритмов</p>

                        <p class="spec indent">по специальности:</p>

                        <p class="spec indent">09.02.03 – Программирование в компьютерных системах</p>

                        <p class="spec indent">Количество часов <u>2</u></p>

                        <p class="new-part indent">РАССМОТРЕНО</p>

                        <p class="indent">на заседании цикловой комиссии <u>Информационные системы и технологии</u></p>

                        <p class="comission indent">наименование П(Ц)К</p>

                        <p class="indent">Председатель ____________<u>/ Шомас Е.А. /</u></p>

                        <p class="sign indent">подпись <span>расшифровка подписи</span></p>

                        <p class="indent">Протокол __________ от «&nbsp;&nbsp;» <u>04</u> 2015 г.</p>

                        <p class="protocol indent">номер <span>дата</span></p>

                        <p class="right">Составил преподаватель</p>

                        <p class="right">Пронина Т.С.</p>

                        <p class="center">Самара, КС ПГУТИ, 2015</p>
                    </div>
                    <div class="practice-info">
                        <p class="center bold">Практическое занятие №9</p>
                        <ol>
                            <li><span class="bold">Наименование</span>: Эффективность алгоритмов</li>
                            <li><span class="bold">Цель занятия</span>: Научиться производить анализ алгоритмов решения
                                задач исходя из их эффективности.
                            </li>
                            <li><span class="bold">Подготовка к работе</span>:
                                <ol>
                                    <li>Изучить тему «Эффективность алгоритмов»</li>
                                    <li>Ответить на вопросы для подготовки к занятию
                                        <ol>
                                            <li>В каких терминах измеряются затраты алгоритма?</li>
                                            <li>Для чего можно использовать число элементарных операций, производимых
                                                при вычислениях в вопросе определения эффективности алгоритма?
                                            </li>
                                            <li>Какие функции называются <br/>
                                                - полиномиальными <br/>
                                                - экспоненциальными?
                                            </li>
                                            <li>Чем отличаются друг от друга полиномиальные функции?</li>
                                            <li>Как отличаются друг от друга рабочие периоды двух алгоритмов, если их
                                                функции имеют одну и ту же старшую степень?
                                            </li>
                                            <li>Что измеряют с помощью функций временной сложности?</li>
                                            <li>На какой знак можно заменить знак равенства в формуле
                                                f(x)=O(q(n)) при определении эффективности алгоритмов?
                                            </li>
                                            <li>Прочитайте формулы: <br/>
                                                f(n)=O(q(n))<br/>
                                                |f(n)|≤C|q(n)|
                                            </li>
                                            <li>Можно ли сказать, что формулы вопроса 3.2.8 эквивалентны?</li>
                                            <li>Какие функции называются функциями одного порядка роста?</li>
                                        </ol>
                                    </li>
                                </ol>
                            </li>
                            <li><span class="bold">Литература</span>:
                                <ol>
                                    <li>Хаггарти. Дискретная математика для программистов М. Техносфера. 2012 – 320 с.
                                    </li>
                                    <li>Конспект лекций по учебной дисциплине «Теория алгоритмов»</li>
                                    <li>Приложение к практическому занятию №9</li>
                                </ol>
                            </li>
                            <li><span class="bold">Перечень используемых материалов</span>:
                                <ol>
                                    <li>Канцелярские принадлежности</li>
                                    <li>Бланки для отчета</li>
                                </ol>
                            </li>
                            <li><span class="bold">Задание на занятие:</span>:
                                <ol>
                                    <li>Используя иерархию функций (см. приложение А) определите порядок роста у
                                        следующих функций временной сложности:
                                        <div><img src="img/practices/9/1.png"
                                                  alt=""/></div>
                                    </li>
                                    <li>Покажите, что 2n^2+4n=θ(n^2)</li>
                                    <li>
                                        Приведите один из примеров иерархии и определяющую порядок роста функций в
                                        текстовой и графической формах. Куда в этом примере можно вставить n^4 logn.
                                    </li>
                                </ol>
                            </li>
                            <li><span class="bold">Порядок выполнения работы</span>:
                                <ol>
                                    <li>Получите допуск к работе</li>
                                    <li>Выполните задания 6.1, 6.2, 6.3</li>
                                    <li>Сдайте отчет преподавателю, получите зачёт</li>
                                </ol>
                            </li>
                            <li><span class="bold">Содержание отчета</span>:
                                <div class="italic">Решение задач 6.1, 6.2, 6.3</div>
                                <div class="italic">Ответы на контрольные вопросы</div>
                            </li>
                            <li><span class="bold">Контрольные вопросы</span>:
                                <ol>
                                    <li>Какие параметры располагаются на самом левом и на самом правом конце иерархии из
                                        примера временной сложности?
                                    </li>
                                    <li>Куда в иерархии временной сложности можно вставить функции:
                                        <div><img src="img/practices/9/2.png"
                                                  alt=""/></div>
                                    </li>
                                </ol>
                            </li>
                        </ol>
                        <div class="work-done-by">
                            <span>Работу составил преподаватель</span>
                            <span class="right-float">Пронина Т.С.</span>
                        </div>
                    </div>
                    <div class="additional">
                        <p class="center bold">Приложение к практическому занятию №9</p>

                        <div>Одна из центральных задач информатики — создание и анализ «эффективности» компьютерных
                            алгоритмов. Для успешного выполнения такого анализа нам необходимо уметь измерять затраты
                            алгоритма в терминах времени и компьютерной памяти. Для этого, в частности, мы оцениваем
                            время, необходимое для вычисления значения числовой функции. Один из способов оценки
                            заключается в подсчете элементарных операций, которые производятся при вычислениях.
                        </div>
                        <div>Например, чтобы установить, есть ли данное слово X в словаре, содержащем n слов, мы могли
                            бы применить последовательный поиск. Названный алгоритм сравнивает слово X с первым словом в
                            словаре, затем со вторым, и т. д., пока слово X не будет найдено в словаре или, в наихудшем
                            случае, не будет найдено. Очевидно, в наихудшем случае будет произведено п сравнений. С
                            другой стороны, при двоичном (дихотомическом) способе слово X сравнивается со «средним» из
                            словаря, а потом, учитывая лексикографическое упорядочение слов, принимается решение о том,
                            в какой части словаря (до «среднего» слова или после него) продолжать поиск. Этот процесс
                            повторяется в выбранной половине словаря и т. д. В наихудшем случае (слово отсутствует в
                            словаре) двоичный поиск сделает 1+log_2⁡n сравнений. Как видно из таблицы 1, двоичный поиск
                            куда более эффективен, чем последовательный.
                        </div>
                        <div><img src="img/practices/9/3.png"
                                  alt=""/></div>
                        Напомним, что <img src="img/practices/9/4.png"
                                           alt=""/>

                        <div><span class="bold">Пример 1.</span> На выполнения алгоритмов А, В, С, D и Е требуется n,
                            3n^2, 2n2 + 4n, n3 и 2n элементарных операций соответственно. Подсчитайте время, необходимое
                            на работу алгоритмов при n=1, n=10, n=100, n=1000, если одна элементарная операция
                            совершается за 1 миллисекунду.
                        </div>
                        <div><span class="bold">Решение</span>Ответы сведены в таблице 2.</div>
                        <div>Как видно из таблицы, существует огромная качественная разница между формулами, включающими
                            в себя степени n (полиномиальные функции), и теми, в которых n выступает в качестве
                            показателя (экспоненциальные функции). Полиномиальные функции отличаются друг от друга
                            величиной старшей степени переменной n. Если функции имеют одну и ту же старшую степень n,
                            то рабочие периоды соответствующих алгоритмов близки друг к другу (см. алгоритмы В и С)
                            <br/>
                            Таблица 2
                        </div>
                        <div><img src="img/practices/9/5.png"
                                  alt=""/></div>
                        <div>Предположим, что функции f (n) и g (n) измеряют эффективность двух алгоритмов, их обычно
                            называют функциями временной сложности. Будем говорить, что порядок роста функции f (x) не
                            больше, чем у g (х), если найдется такая положительная константа С, что |f(n)|≤C|g(n)| для
                            всех достаточно больших значений n. Этот факт обозначают как f(x)=O(g(n)).
                            Две функции, такие как n2 и 2n2+4n, каждая из которых имеет порядок роста другой, называются
                            функциями одного порядка роста. Функции, ассоциированные с алгоритмами B и C в примере 1
                            имеют один и тот же порядок роста и, как следствие, соответствующие длительности работы
                            алгоритмов близки.
                        </div>
                        <div>Мы можем определить некоторую иерархическую структуру на множестве функций, каждая из
                            которых имеет больший порядок роста, чем предыдущая. Один из примеров такой иерархии имеет
                            вид:
                        </div>
                        <div><img src="img/practices/9/6.png"
                                  alt=""/></div>
                        <div>В последствии мы могли бы детализировать эту иерархию, вставив (log n) между n и n2, (n2
                            log n) между n2 и n3 и т.д.
                        </div>
                        <div>В этой иерархии важно то, что двигаясь от ее левого края к правому, мы встречаем функции
                            все большего порядка роста. Следовательно, чем правее в этом ряду стоит функция, тем быстрее
                            растут ее значения по сравнению с ростом аргумента n. Сравнительные графики некоторых из
                            перечисленных функций приведены на рисунке 1.
                        </div>
                        <div><img src="img/practices/9/7.png"
                                  alt=""/></div>
                        <div>Теперь любой функции временной сложности f(n) мы можем сопоставить некоторую функцию g(n)
                            из описанной иерархии таким образом, что f(n) будет иметь порядок роста не более чем g(n),
                            но больше, чем любая из функций иерархии, стоящая левее g(n). Чтобы сделать это, мы с
                            помощью нашей иерархии выделяем в данной функции наиболее быстро растущий член (его еще
                            называют старшим членом) и сопоставляем нашей функции временной сложности соответствующую
                            функцию в иерархии.
                        </div>
                        <div>Рассмотрим, например, функцию f(n) = 9n + 3n6 + 7logn. Ясно, что мультипликативные
                            константы (числовые коэффициенты, на которые умножается то или иное выражение) не влияют на
                            порядок роста функций. Поэтому 9n=O(n), 3n6 = O(n6), 7 logn = O(logn). Поскольку n и logn
                            появляются в иерархии раньше, чем, мы получаем, что как и 9n, так и 7 logn принадлежат
                            классу O(n6). Следовательно, f(n) = O(n6), и наиболее быстро растущим членом у f(n) является
                            член 3n6. Таким образом, значения функции f(n) растут не быстрee, чем возрастают значения
                            n6. Фактически, в этом примере функция f(n) имеет тот же порядок роста, что и n^6.
                        </div>
                        <div>При вычислении функции временной сложности любого алгоритма, необходимо решить, что в
                            данной задаче следует взять в качестве параметра n и какие элементарные операции стоит
                            учитывать при расчетах.
                        </div>
                        <div><span class="bold">Пример 2. </span> Найдите функцию временной сложности следующего
                            фрагмента алгоритма, написанного на псевдокоде, подсчитав количество операторов присваивания
                            x≔x+1, которые в нём выполняются.
                        </div>
                        <pre>
                            begin
                                for i≔1 to 2n do
                                    for j≔1 to n do
                                        for k≔1 to j do
                                        x≔x+1;
                            end
                        </pre>
                        <div><span class="bold">Решение.</span> Внешний цикл (параметризованный переменной j)
                            повторяется 2n раз. Цикл, помеченный переменной j, повторяется n раз. При каждом значении j
                            операция x≔x+1 выполняется j раз. Следовательно, при каждом значении параметра внешнего
                            цикла i операция x≔x+1 выполняется 1+2+⋯+n раз, что равно 1/2n(n+1).
                        </div>
                        <div>Значит функция временной сложности T(n) определяется формулой:</div>
                        <div><img src="img/practices/9/8.png"
                                  alt=""/></div>
                    </div>
                </article>

            </div>
            <button class="close-button"><i class="fa fa-close"></i><span>Close</span></button>
        </section>
    </div>
</div>
<!-- /container -->
<script src="js/classie.js"></script>
<script src="js/main.js"></script>
</body>
</html>
